<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title><![CDATA[The PHP Foundation]]></title><description><![CDATA[Supporting, Advancing, and Developing the PHP Language]]></description><updated>2025-08-04T10:39:52+00:00</updated><entry><author><name>Larry Garfield</name><uri>https://github.com/Crell</uri></author><title type="html"><![CDATA[PHP 8.4: How Property Hooks Happened]]></title><content type="html"><![CDATA[<p>PHP 8.4 is coming on 21 November this year.  It includes a host of new functionality, but the biggest, in more ways than one, is Property hooks.  Given the excitement around it, as well as its size, the PHP Foundation's Roman Pronsky asked me to write up a bit about the process we went through to produce this beast.</p>

<p>What eventually became the twin RFCs of Property Hooks and Asymmetric Visibility is actually a very old discussion.  We'll look back at the decade-plus saga that got us here, how Ilija Tovilo and I got sucked in, how the design came to be, and how we managed to get it across the finish line.  Here's a teaser: It would not have happened without the PHP Foundation.</p>

<h2 id="ancient-history">Ancient history</h2>

<p>Ilija and I were not the first RFC to propose "property accessors," as they're called in most languages.  In fact, our RFC was the fifth:</p>

<ol>
<li>2009: <a href="https://wiki.php.net/rfc/propertygetsetsyntax">Property get/set syntax</a> by Dennis Robinson.  The core concepts and arguments behind it are all there, and haven't really changed in 15 years.  It never went to a vote.</li>
<li>2012: <a href="https://wiki.php.net/rfc/propertygetsetsyntax-v1.2">Property get/set syntax v1.2</a> by Clint Priest and Nikita Popov.  It didn't pass the 2/3 threshold for a vote, but did pass 50%.</li>
<li>2013: <a href="https://wiki.php.net/rfc/propertygetsetsyntax-alternative-typehinting-syntax">Property get/set syntax alternate typehinting syntax</a>, by Nikita Popov.  An alternate approach that proved very unpopular, failing 3 to 12.  However, it included a shorthand syntax that looks suspiciously like what eventually became property types.</li>
<li>2021: <a href="https://wiki.php.net/rfc/property_accessors">Property Accessors</a> by Nikita Popov. More of a brainstorm of what property accessors could be, including specific use-case options like <code>lazy</code> or <code>guard</code>.  It never went to a vote, but Nikita did note that "We could likely get 80% of the value of accessors by supporting read-only properties and 90% by also supporting private-write properties."  (I don't fully agree, but much of the value is in private-write.)</li>
</ol>

<p>All of these attempts had a few things in common:</p>

<ul>
<li>Pseudo-functions that live on properties and intercept get/set operations.</li>
<li>Asymmetric visibility</li>
<li>Interface properties</li>
</ul>

<h2 id="a-new-team-enters-the-arena">A new team enters the arena</h2>

<p>Fast forward to the summer of 2022.  Ilija Tovilo decided he wanted to take a swing at accessors next, and approached me for help.  Ilija and I had already worked together on the <a href="https://wiki.php.net/rfc/enumerations">Enums RFC</a>, so we knew we worked well together.  In part, that's because we have very different skill sets.  Ilija is rapidly becoming one of the most PHP engine-knowledgeable people around and quite proficient at writing C code, but is, by his own admission, not the most proficient writer of English.  I am a weirdo who enjoys language research, designing away edge cases, and can type fast enough to keep up with the Internals mailing list.  We complement each other well.</p>

<p>Illija is also fully funded by the PHP Foundation to work on the engine, without which this amount of work would have been impossible.  I work on a volunteer basis, and as my employers allow.</p>

<p>(Side note: As of this writing, I am between jobs.  If you're looking for a highly-experienced PHP Staff/Principal Engineer with experience in design, architecture, and leading teams, please <a href="https://github.com/Crell/">reach out</a> and let's talk!)</p>

<h2 id="research%2C-then-development">Research, then development</h2>

<p>With the initial goal of "making Nikita's proposal work-ish," I started digging into the research and design side.  My <a href="https://github.com/Crell/php-rfcs/blob/master/property-hooks/research.md">initial brainstorming</a> shows where our thoughts were at the time.  In short:</p>

<ul>
<li>There are two models of accessors: In untyped languages without visibility controls&mdash;like JavaScript and Python&mdash;accessors are methods with funny syntax.  In typed languages with visibility controls&mdash;like C#, Swift, and Kotlin&mdash;accessors are enhancements to a defined property.  As PHP is, let's face it, a typed language with visibility controls, that was clearly the model to follow (as had all previous RFCs).</li>
<li>Yes, we really would need asymmetric visibility, accessors, and interface properties.  While technically separate features, they make the most sense in combination.</li>
<li>The whole scope would be huge, so we needed to break it up where we could.  Splitting Asymmetric visibility off to its own RFC was the most natural place, which would be made easier by using Swift's <code>private(set)</code> style syntax.</li>
</ul>

<p>So in August of 2022 we put forward the first <a href="https://wiki.php.net/rfc/asymmetric-visibility">asymmetric visibility</a> RFC.  Given there was already a clear appetite for such functionality based on list discussions and on the recent <code>readonly</code> addition, which Nikita explicitly intended as a "junior asymmetric visibility," we expected some bikeshedding but overall a straightforward process.</p>

<p>Boy were we wrong.</p>

<h2 id="asymmetric-support">Asymmetric support</h2>

<p>The Asymmetric Visibility RFC was far more contentious than we expected. Some people hated the idea.  Some wouldn't accept anything but the C#-style syntax.  We ran a poll of various different approaches, and our initial proposal (Swift-style placement and syntax) ended up winning by a slim margin, but disappointingly "the consensus position isn't your position, sorry" didn't really persuade anyone.</p>

<p>Eventually, Asymmetric visibility finally went down in a 14:12 vote in January of 2023.  RFCs need 2/3 majorities to pass, so 14:12, while a simple majority, isn't enough.</p>

<h2 id="hooking-it-up">Hooking it up</h2>

<p>The failure of asymmetric visibility was a blow to both of us.  In most cases we didn't even know why the people who voted "no" did so, which made addressing their concerns guesswork.  Had we just wasted our time?  Would accessors even be acceptable?  The current RFC process is very bad at providing that kind of actionable feedback.</p>

<p>While no one from the Foundation mentioned it, we were also both acutely aware that Ilija had been working on paid time for a proposal that ended up failing.</p>

<p>Nonetheless, we had split the RFC in two deliberately so that even if only one was successful there was still a benefit.  We therefore turned our attention to the accessor part of the proposal (which included interface properties) and continued working.</p>

<p>The model we developed was essentially a "direct port from Swift, with a few slight renames."</p>

<p>The initial design included:</p>

<ul>
<li><code>get</code> - Totally takes over reading, and there's no physical property created.</li>
<li><code>set</code> - Totally takes over writing, and there's no physical property created.</li>
<li><code>beforeSet</code> - Intercepts the writing of a property but doesn't change the actual write itself.</li>
<li><code>afterSet</code> - Called after the property is written, doesn't change the actual write itself.</li>
</ul>

<p>This is also when we changed the name from "accessors" to "hooks," which seemed a more accurate description given that model.  This later ended up not making sense, but Ilija had already taken the time to rename everything in the patch, so it was too much work to change back.  Sorry.</p>

<p>The RFC text itself grew and grew.  PHP is a very mature (read: complex) language, and so there were lots of nooks and crannies that we had to account for.  Properties touch on almost everything: References, arrays, inheritance, final properties, interfaces, interaction with <code>readonly</code>, interaction with <code>__get</code>/<code>__set</code>, serialization, constructor property promotion, reflection...</p>

<p>PHP is a big language, and we needed to think through and implement every possible edge case to avoid booby traps.</p>

<h2 id="some-very-good-advice">Some very good Advice</h2>

<p>We finally had a working design and implementation by April 2023 or so, but were quite nervous about it.  It was big, and we were both still smarting from the loss of asymmetric visibility.  Roman suggested that he run it past the PHP Foundation's Advisory Board for feedback first before going to the list, which turned out to be the best thing we could do.</p>

<p>The Board came back with mostly positive feedback; they liked the concept, the design, the detail... but having 4 separate hooks felt very clumsy to them.  Especially with get/set wiping the backing property entirely and leaving the developer on their own.</p>

<blockquote>
<p><strong>The PHP Foundation's Advisory Board</strong> serves as a vital bridge between our major sponsors and the PHP development community. It's a Slack channel where we share early updates, insights, and ask for feedback. As well as receive insights and queries from sponsors' representatives. <br><br>

Companies interested in joining this influential group and directly contributing to the future of PHP can become members of the Advisory Board by contributing a minimum of $12,000 to The&nbsp;PHP&nbsp;Foundation as at least a Silver Sponsor. <br/><br/>

<strong><a href="https://thephp.foundation/sponsor/">Learn more about sponsorship opportunities.</a></strong><br/>
</p>
</blockquote>

<p>I don't have the original chat log, but that resulted in a brief exchange that went approximately like this:</p>

<pre><code class="text">Roman: The Advisory Board says three different set-ish hooks are a problem  
Larry: Well, we kinda have to, because you can't access a property 
       from within its own hook, that doesn't make sense.  
Ilija: Er, actually we could do that easily.  
Larry: Wait, what?  That... how... why...  
Larry: *does some research*  
Larry: Well crap, that's exactly what Kotlin does.  
       Why didn't we research Kotlin in the first place?  
Ilija: ¯\_(ツ)_/¯  
Ilija: Well, I just switched it over to that. Looks nicer.
</code></pre>

<p>And so there we were, with half as many syntaxes for the same functionality, and a feature name (hooks) that no longer made sense.  Oh well.</p>

<p>We finally made a public proposal at the start of May 2023.  Initial feedback was quite positive, though there was some pushback, including around the syntax from people who wanted the Javascript/Python style (naturally).  And the length.  Oh, the length.  If hooks isn't the longest RFC ever proposed, it's close.  But as we reiterated many times, that's because the problem space itself is highly complex.</p>

<p>Sadly, time was not on our side.  Ilija was still working out some implementation edge cases and PHP 8.3’s feature-freeze was rapidly approaching.  So in early July, almost exactly a year after we started working on it, we decided to postpone hooks until 8.4 to give such a large change enough time to settle in and get adjusted if needed.</p>

<h2 id="take-2">Take 2</h2>

<p>After many distractions, we were able to bring the topic back up in <a href="https://externals.io/message/122445">February of 2024</a>, with the intent to bring it to a vote quickly, in March.  (We were so naive.)</p>

<p>There was a lot more discussion this time around, though a lot of it was re-hashing edge cases we'd already addressed.  We also spent a considerable amount of time talking with the Foundation's developer team.  They, by and large, represent the most experienced developers of PHP Internals today, and were an invaluable resource.  That we could talk to them in real time via the Foundation's private chat also helped, as that's a far easier way to handle back-and-forth than a mailing list.</p>

<p>There were a few significant changes we did end up making in response to feedback, from both the list and the Foundation team.  Most importantly, Ilija managed to make array properties work, which had been a challenge due to references.  Once again, being able to attack the problem from two directions (design and ergonomics from me, implementation from Ilija) let us improve the overall experience dramatically.</p>

<h2 id="down-to-the-wire">Down to the wire</h2>

<p>Even then, with all the positive feedback, it wasn't clear to us if it would pass.  Many people on the list had expressed support, but a lot of them were non-voters.</p>

<p>Others had expressed essentially "fearful support"; They liked the idea, couldn't find fault with the implementation, but were concerned about just how big and complex the feature was.</p>

<p>Still others, for various reasons, suggested moving certain sub-features to a separate, future RFC. Which is often code for "I don't like this part, but I don't want to vote against the RFC because of it, so please let me vote against it separately."  We explained, repeatedly, that this was already the slimmed down, partial version.  The other part was asymmetric visibility.</p>

<p>After a lot of discussion and with a lot of trepidation, we called the vote in mid-April of 2024.  It passed 42:2.  I don't understand PHP Internals at times.</p>

<h2 id="asymmetric-visibility-2%3A-the-wrath-of-ilija">Asymmetric Visibility 2: The Wrath of Ilija</h2>

<p>Several people pointed out that hooks without asymmetric visibility had significant holes in it.  They were right, which is why we'd originally proposed that first.  We had decided that if hooks pass, we would take a second swing at asymmetric visibility.  So we did.</p>

<p>The only actionable feedback we'd gotten the first time around was that without support for combining <code>readonly</code> and asymmetric visibility, the RFC felt "incomplete."  We went through a few variations on how to address that before landing on the final solution: Change <code>readonly</code> from being implicitly <code>private(set)</code> to implicitly <code>protected(set)</code>.  Otherwise, the discussion was mostly a retread of the year before.</p>

<p>We were still stressing out about this one, too.  It hadn't passed before, why would it now?  However, this time it passed 24:7 at the start of August 2024.</p>

<p>Looking at the results, while there were two people who changed from a No to a Yes, the biggest change from the first vote was simply who voted.  Most of the previous No votes... didn't vote this time.  But entirely new people showed up to vote yes.  Showing up to vote matters, folks.</p>

<h2 id="on-to-the-next-adventure">On to the next adventure</h2>

<p>25 months after the process started, PHP now joins the cadre of languages with robust, flexible properties that can do more than just hold dumb values.  It's been a wild ride, and at many points a needlessly stressful one.  The end result, though, is a host of powerful new features that make PHP 8.4 the most exciting PHP release in several years.  Really, they're the best thing since enums...</p>

<p>I hope this tale is a useful insight for folks into how the sausage is made.  Now go enjoy interface properties, hooks, and asymmetric visibility.  Or enjoy not using hooks, but having the option to, which eliminates a lot of code.  Both work.</p>
]]></content><link href="https://thephp.foundation/blog/2024/11/01/how-hooks-happened/"/><id>https://thephp.foundation/blog/2024/11/01/how-hooks-happened/</id><updated>Wed, 06 Nov 2024 00:00:00 +0000</updated></entry><entry><author><name>Arnaud Le Blanc</name><uri>https://github.com/arnaud-lb</uri></author><author><name>Derick Rethans</name><uri>https://derickrethans.nl</uri></author><author><name>Larry Garfield</name><uri>https://www.garfieldtech.com/</uri></author><title type="html"><![CDATA[State of Generics and Collections]]></title><content type="html"><![CDATA[<p>Generics have been on the list of wanted features for a long time by numerous PHP developers. The topic is often brought up in "What's New in PHP?" talks as well during Q&amp;A.</p>

<p>In this article we will be exploring the different approaches, and what their current state is.</p>

<ul>
<li><a href="#full-reified-generics">Full Reified generics</a></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#other-alternatives">Other alternatives</a>

<ul>
<li><a href="#static-analysis">Static Analysis</a></li>
<li><a href="#erased-generic-type-declarations">Erased Generic Type Declarations</a></li>
<li><a href="#fully-erased-type-declarations">Fully Erased Type Declarations</a></li>
</ul></li>
<li><a href="#generic-arrays">Generic Arrays</a>

<ul>
<li><a href="#fluid-arrays">Fluid Arrays</a></li>
<li><a href="#static-arrays">Static Arrays</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h1 id="full-reified-generics">Full Reified generics</h1>

<p>With generics you can define classes with placeholders for the types of their properties and methods. These can then be specified when instances of the class are created. This enables code reusability and type safety across different data types.  "Reified" generics are implementations where the generic type information is defined and carried through to runtime, allowing for runtime enforcement of generic requirements.</p>

<p>As PHP syntax, this could look like:</p>

<pre><code>class Entry&lt;KeyType, ValueType&gt;
{
    public function __construct(protected KeyType $key, protected ValueType $value)
    {
    }

    public function getKey(): KeyType
    {
        return $this-&gt;key;
    }

    public function getValue(): ValueType
    {
        return $this-&gt;value;
    }
}

new Entry&lt;int, BlogPost&gt;(123, new BlogPost());
</code></pre>

<p>In the instantiated class, the generic type <code>KeyType</code> will be replaced with <code>int</code>, and each instance of <code>ValueType</code> with <code>BlogPost</code>, resulting in an object behaving like the following class definition:</p>

<pre><code>class IntBlogPostEntry
{
    public function __construct(protected int $key, protected BlogPost $value)
    {
    }

    public function getKey(): int
    {
        return $this-&gt;key;
    }

    public function getValue(): BlogPost
    {
        return $this-&gt;value;
    }
}
</code></pre>

<p>There have been a few attempts in the past to add this functionality to PHP as well. Nikita Popov attempted the <a href="https://github.com/PHPGenerics/php-generics-rfc/issues/45">most comprehensive experimental implementation</a> in 2020/2021, following up on <a href="https://wiki.php.net/rfc/generics">a draft RFC</a> from 2016, and a <a href="https://www.reddit.com/r/PHP/comments/j65968/comment/g83skiz/">reddit post</a> summarizing the remaining challenges.</p>

<p>At the start of this year, under the auspices of the PHP Foundation, Arnaud Le Blanc <a href="https://github.com/arnaud-lb/php-src/pull/4">restarted this effort</a>, using Nikita's work as a starting point. Although many technical issues have been addressed, plenty of them are still unresolved.</p>

<p>A key challenge is type inference. The use of generics tends to increase code verbosity because it requires type arguments to be specified each time a generic type is referenced. This is demonstrated in the following PHP code snippet:</p>

<pre><code>function f(List&lt;Entry&lt;int,BlogPost&gt;&gt; $entries): Map&lt;int, BlogPost&gt;
{
    return new Map&lt;int, BlogPost&gt;($entries);
}

function g(List&lt;BlogPostId&gt; $ids): List&lt;BlogPost&gt;
{
    return map&lt;int, BlogPostId, BlogPost&gt;($ids, $repository-&gt;find(...));
}
</code></pre>

<p>Type inference can reduce this verbosity by letting the compiler deduce the appropriate types automatically for us. For instance, in the examples above, the compiler might automatically determine the correct types for <code>new Map()</code> and <code>map()</code>. However, this is hard in PHP. Quoting Nikita, "primarily due to the very limited view of the codebase the PHP compiler has (it only sees one file at a time)".</p>

<p>Consider the following example:</p>

<pre><code>class Box&lt;T&gt;
{
    public function __construct(public T $value) {}
}

new Box(getValue());
</code></pre>

<p>In this scenario, the type of the getValue() expression is unknown until the function is loaded at runtime, making it impossible to infer <code>T</code> in <code>new Box(...)</code> during compilation.</p>

<p>We could assign <code>T</code> at runtime based on the return <em>value</em> of the function, but this would result in unstable typing. In the previous example the type of <code>new Box()</code> would depend on the <em>implementation</em> of the return value of <code>getValue()</code>, which may be too specific: combine that with the fact that Box is invariant, and this code would break very quickly when trying to do anything useful with the Box instance:</p>

<pre><code>interface ValueInterface {}
class A implements ValueInterface {}
class B implements ValueInterface {}

function getValue(): ValueInterface
{
    return new A();
}

function doSomething(Box&lt;ValueInterface&gt; $box)
{
}

$box = new Box(getValue()) // runtime: Box&lt;A&gt;, statically: Box&lt;ValueInterface&gt;
doSomething($box); // accepts Box&lt;ValueInterface&gt;, not Box&lt;A&gt;
</code></pre>

<p>Typing is most useful when it’s based on compile-time / static information that doesn’t depend on the implementation.</p>

<p>Note: In this example, <code>Box</code> is invariant, as it is often the case of generic classes. This means that <code>Box&lt;X&gt;</code> is neither a sub-type or a super-type of <code>Box&lt;Y&gt;</code> regardless of the relationship between <code>X</code> and <code>Y</code>, so <code>Box&lt;A&gt;</code> is not a sub-type of <code>Box&lt;ValueInterface&gt;</code>, and <code>doSomething()</code> can not accept a <code>Box&lt;A&gt;</code>.</p>

<p>A generic class is invariant when one of its type placeholders is used both in read (e.g. as a return type) and write (e.g. a parameter type) positions at the same time. A property type is both in read and write position.</p>

<p>To understand why, consider the following example:</p>

<pre><code>function changeValue(Box&lt;ValueInterface&gt; $box)
{
    $box-&gt;value = new B();
}
</code></pre>

<p>The <code>changeValue()</code> function accepts a <code>Box&lt;ValueInterface&gt;</code>, thus should be able to assign any sub-type of <code>ValueInterface</code> to <code>$box-&gt;value</code>. However, if we pass a <code>Box&lt;A&gt;</code> (with <code>A</code> a sub-type of <code>ValueInterface</code>), this contract breaks when we assign a value that is a sub-type of <code>ValueInterface</code> but not of <code>A</code>.</p>

<p>The common solution in other generic languages is to allow a type parameter to be marked variant in only one direction (typically "in" or "out"), provided it is used only in a parameter or return position, respectively.  That allows that type parameter to be contravariant or covariant, as appropriate.</p>

<h3 id="hybrid-approach-to-type-inference">Hybrid Approach to Type Inference</h3>

<p>To address these challenges, we explored a hybrid approach, that lets us implement static type inference of generic parameters without having the full information available at compile time. This approach represents unknown types as symbols at compile time (e.g. the type of the expression <code>getValue()</code> is represented as <code>fcall&lt;getValue&gt;</code>). Symbolic types can be resolved at runtime when needed after functions and classes have been loaded, at a fraction of the cost of running the entire analysis at runtime. This operation can be cached (in inline caches) for the duration of the request, and maybe in caches similar to the inheritance cache.</p>

<p>A proof of concept was implemented, and used to implement data-flow based, local, unidirectional type inference of generic type parameters, with the same behaviour as PHPStan/Psalm. The approach works, and could be used to experiment with other flavours of type inference.</p>

<h3 id="performance-considerations">Performance Considerations</h3>

<p>Another concern with generics is their impact on performance. Preliminary benchmarks indicated:</p>

<ul>
<li>Generics do not affect the performance of non-generic code.</li>
<li>Simple generic code shows a modest performance degradation of about 1-2% compared to specialized code.</li>
</ul>

<p>However, later exploration has shown that compound types (such as unions) can lead to super-linear time complexity in type checking, potentially resulting in more substantial performance drawbacks. For example, checking whether <code>A|B</code> accepts <code>B</code> is linear, but checking <code>Box&lt;A|B&gt;()</code> against <code>Box&lt;A|B&gt;()</code> is O(nm).</p>

<p>Super-linear complexity is also reached when merging compound types during the resolution of symbolic types.</p>

<h3 id="future-directions">Future Directions</h3>

<p>Ongoing challenges for reified generics include:</p>

<ul>
<li>Evaluating the effects of compound types and extreme cases</li>
<li>Implement type-checking inline caches, and research more sophisticated algorithms for checking compound types</li>
<li>Exploring eager-autoloading (preloading, but automatic), or inheritance-cache alike, to reduce the amount of symbolic types</li>
</ul>

<h1 id="collections">Collections</h1>

<p>One of the main use cases for generics that often gets brought up is the need for typed arrays. In PHP, the swiss-army knife array type can be used (and abused) for lots of reasons. But you can't currently enforce the types to be used as key or value.</p>

<p>In a parallel project, we have been working on a dedicated Collections syntax as a less-challenging alternative to full generics.</p>

<p>Collections would come in three flavours: sets, sequences, and dictionaries. Sets and Sequences only define a value type, whereas Dictionaries have key and value types. The syntax of these could be as follows:</p>

<pre><code>class Article
{
    public function __construct(public string $subject) {}
}

collection(Seq) Articles&lt;Article&gt;
{
}

collection(Dict) YearBooks&lt;int =&gt; Book&gt;
{
}
</code></pre>

<p>You can then instantiate sequences and collections like you would do with a normal class:</p>

<pre><code>$a1 = new Articles();
$b1 = new YearBooks();
</code></pre>

<p>Sequences and Dictionaries will automatically have <a href="https://github.com/php/php-src/compare/master...derickr:php-src:collections&#35;diff-eeb1e0848e9a25b7492398bf5ddf9be15995a67d44a23c336869bf9f36910d1b">many methods defined</a> on them, providing a base functionality like PHP already has with the myriad of <code>array_*</code> functions. If you use the defined methods to add or update elements in the collection, then the type for keys and values have to match the ones as defined on the collection.</p>

<p>In the example above, the <code>add()</code> method for the YearBooks dictionary then requires int to be used as key, and Book as value. For the main manipulation methods (add, get, unset, and isset), ArrayAccess style overloaded operations will also work, as well as potentially operator overloads.</p>

<p>One of the drawbacks of Collections is that you need to declare them. Following adopted practise, that would mean a single line declaration in a separate file for each collection.</p>

<p>Another concern is potentially higher memory usage, as for each class PHP will have to keep a corresponding class entry, including a list of all the associated methods.</p>

<p>And a third concern is that there is no instanceof/is-a relationship between collections of compatible types, for example:</p>

<pre><code>class A {}
class B extends A {}

seq As&lt;A&gt; {}
seq Bs&lt;B&gt; {}

new B() instanceof A // true
new Bs() instanceof As // false
</code></pre>

<p>Or:</p>

<pre><code>namespace Foo;
seq As&lt;A&gt; {}

namespace Bar;
seq As&lt;A&gt; {}

namespace;
new Foo\As instanceof Bar\As; // false
</code></pre>

<p>Collections, although less powerful, can be an alternative to generics in many use cases, but without much of the complexity. The implementation as outline above is also significantly easier. An <a href="https://github.com/derickr/php-src/tree/collections">experimental branch is also available</a>.  However, if full generics are found to be viable and supported, implementing Seq, Set, and Dict directly on standard generics would be significantly preferable.</p>

<p>Larry Garfield has <a href="https://github.com/Crell/php-rfcs/blob/master/collections/research-notes.md">conducted research</a> into other languages and how expansive their collection APIs are.  It's still in rough form, but the consensus seems to be "include everything", possibly broken up into discrete interfaces.  The rough recommendations at the end of the document suggest a likely way forward.</p>

<p>You can find a patch for collections at <a href="https://github.com/php/php-src/pull/15429">https://github.com/php/php-src/pull/15429</a></p>

<h1 id="other-alternatives">Other alternatives</h1>

<h2 id="static-analysis">Static Analysis</h2>

<p>Recent years have seen the emergence of static analysers. Both <a href="https://phpstan.org/blog/generics-in-php-using-phpdocs">PHPStan</a> and <a href="https://psalm.dev/docs/annotating_code/templated_annotations/">Psalm</a> support generics via doc block annotations, and are frequently used in open source libraries and private projects.</p>

<p>Here is an example of a generic Dict class when using PHPStan and Psalm:</p>

<pre><code>/**
 * @template Key
 * @template Value
 */
class Dict
{
    /**
     * @param array&lt;Key,Value&gt; $entries
     */
    public function __construct(private array $entries) {}

    /**
     * @param Key $key
     * @param Value $value
     */
    public function set($key, $value): self
    {
        $this-&gt;entries[$key] = $value;
        return $this;
    }
}

/** @param Dict&lt;string,string&gt; $dict */
function f($dict) {}

$dict = new Dict([1 =&gt; 'foo']);
$dict-&gt;set("foo", "bar"); // Static analyser error
$dict-&gt;set(1, "bar");     // Ok
f($dict);                 // Static analyser error
</code></pre>

<p>The docblock annotations are named “template” for historical reasons, but they implement a generics flavour very close to Java’s: Generic types are checked at static analysis time, and are not visible at runtime.</p>

<p>This offers some benefits of generics, such as type safety, with the following drawbacks:</p>

<ul>
<li>Docblocks can be verbose</li>
<li>Type checking requires running a separate tool (like PHPStan or Psalm)</li>
<li>Generic type information is entirely unavailable at runtime.</li>
<li>Generic type information is not enforced at runtime (so if you don't run a static analysis tool in advance, they accomplish nothing).</li>
</ul>

<h2 id="erased-generic-type-declarations">Erased Generic Type Declarations</h2>

<p>Seeing the difficulties with implementing reified generics in PHP core, it has been proposed to implement them only syntactically, leaving the task of type checking to static analysers.</p>

<p>In this alternative, the PHP syntax would be changed so that type declarations, class declarations, and function declarations accept generic syntax, but the PHP engine would not check them.</p>

<p>We can call these “Erased” type declarations because the engine will simply ignore them at runtime. This alternative could be implemented in various ways:</p>

<ul>
<li>As part of php-src</li>
<li>In an extension</li>
<li>In an autoloader</li>
<li>etc</li>
</ul>

<p>Here is what the same Dict class as above would look like:</p>

<pre><code>class Dict&lt;Key,Value&gt;
{
    public function __construct(private array&lt;Key,Value&gt; $entries) {}

    public function set(Key $key, Value $value): self
    {
        $this-&gt;entries[$key] = $value;
        return $this;
    }
}

function f(Dict&lt;string,string&gt; $dict) {}

$dict = new Dict([1 =&gt; 'foo']);
$dict-&gt;set("foo", "bar"); // Static analyser error
$dict-&gt;set(1, "bar");     // Ok
f($dict);                 // Static analyser error
</code></pre>

<p>This addresses the docblock verbosity issue of the Static Analysis alternative, but this introduces an inconsistency: Type declarations cause coercion, but erased generic type declarations will not.</p>

<p>Consider the following example:</p>

<pre><code>class StringList
{
    public function add(string $value)
    {
        $this-&gt;values[] = $value;
    }
}

class List&lt;T&gt;
{
    public function add(T $value)
    {
        $this-&gt;values[] = $value;
    }
}

$list = new StringList();
$list-&gt;add(123); // coerced to string

$list = new List&lt;string&gt;();
$list-&gt;add(123); // NOT coerced to string
</code></pre>

<p>In this scenario, the first call to <code>add()</code> will coerce the argument to string, but not the second one.</p>

<p>In languages like Java, which has erased generics on top of a traditional type system, the compiler does type checking, so inconsistencies like the above do not exist. However, in PHP these are unavoidable.</p>

<p>Another drawback of erased generics is they are not visible at runtime. This would prevent pattern matching from seeing generic type arguments, for example.</p>

<h2 id="fully-erased-type-declarations">Fully Erased Type Declarations</h2>

<p>One way to address the inconsistency issue of Erased Generics is to change all type declarations to be erased. This could be opt-in with a <code>declare()</code> statement:</p>

<pre><code>declare(types=erased);
</code></pre>

<p>In this alternative, the engine would stop checking types at runtime. In the previous example, both calls to <code>add()</code> would have the same behaviour: the value is not coerced. It is then up to the user to check types with an analyser.</p>

<p>This is not uncommon in mainstream interpreted languages, as all of Javascript (via TypeScript), Python, and Ruby have fully erased type declarations.</p>

<p>Letting users opt-in for fully erased typing and generics on a per-file basis would be another option to look at, and would make working with PHPStan/Psalm generics less verbose. Some additional benefits of this solution include:</p>

<ul>
<li>Short-term performance improvements due to the lack of type checking at runtime in opted-in code.</li>
<li>The potential for extending the type system with advanced types like non-empty-string, list, int<range>, class-string, conditional types, and more.</li>
</ul>

<p>However, there would also be significant downsides:</p>

<ul>
<li>It's unclear what impact erased types would have on reflection, or libraries that depend on reflection.</li>
<li>It would make type enforcement dependent on a developer actively choosing to run a static analysis tool, and the majority of the ecosystem right now doesn't use one to begin with.</li>
<li>It effectively creates a third "type mode" that developers would have to account for, in addition to strict and weak typing today.  (Since code with user-defined pseudo types wouldn't be compatible with the type-enforced modes.)</li>
<li>It would not actually resolve the "some types are enforced but not others" question, as anyone who wanted to use generics but not fully-erased types would still be left with partial-enforcement.</li>
<li>PHP is currently unique among major scripting languages for having enforced types. That's a benefit and market advantage we would lose.</li>
</ul>

<h1 id="generic-arrays">Generic Arrays</h1>

<p>This blog post discusses generic objects, but what about arrays?</p>

<h2 id="fluid-arrays">Fluid Arrays</h2>

<p>Arrays are copy on write: Modifying them creates a new copy (if they are referenced elsewhere), and modifies the copy instead. This makes arrays safe to pass around as you don’t need to worry about other functions modifying them (unless passed by reference).</p>

<p>From a typing perspective this means that the type of an array is always defined by its content, and this type can not change because modifying an array creates a new one.</p>

<p>From a generics perspective this is a very convenient property, as this makes arrays variant: They can have supertypes and subtypes, just like any (non-generic) class. In other words, the following code is type safe:</p>

<pre><code>class A {}
class B extends A {}

function f(array $a) {}
function g(array&lt;A&gt; $a) {}
function h(array&lt;B&gt; $a) {}

$array = [new B()];

f($array);
g($array);
h($array);
</code></pre>

<p>Usually, generic containers are invariant because their type placeholders are used in both read and write positions. This is not the case for arrays because they are semantically immutable / copy on write.</p>

<p>So the natural way to implement generic arrays is just as explained above: Let their content define their type. This is illustrated in the example below:</p>

<pre><code>$a = [1];       // array&lt;int&gt;
$b = [new A()]; // array&lt;A&gt;
$c = $b;        // array&lt;A&gt;
$c[] = new B(); // array&lt;A|B&gt;
$b;             // array&lt;A&gt;
</code></pre>

<p>This does provide type safety, because what matters is that types are checked at API boundaries—when passing arguments to functions, returning values, updating object properties:</p>

<pre><code>function f(array&lt;int&gt; $a) {}

$a = [1];
f($a); // ok

$b = [new A()];
f($b); // error
</code></pre>

<p>A PoC has been implemented, but the performance impact is still uncertain. Another issue is that supporting references and/or typed properties may not be possible.</p>

<h2 id="static-arrays">Static Arrays</h2>

<p>An alternative to Fluid Arrays is to fix the type at instantiation time:</p>

<pre><code>$a = array&lt;int&gt;(1); // array&lt;int&gt;
$a[] = new A();     // error
</code></pre>

<p>However, this alternative is very orthogonal to how arrays are used in PHP code today. It also makes arrays invariant:</p>

<pre><code>function f(array&lt;int&gt; $a) {}
function g(array $a) {}

$a = [1];

f($a); // ok
g($a); // error
</code></pre>

<p>To understand why <code>g($a)</code> is an error, remember the explanation about invariance in the Generics section. <code>g()</code> accepts an <code>array</code> (<code>array&lt;mixed&gt;</code>), which means it should be able to add an element of any type to it. However, if we pass an <code>array&lt;int&gt;</code> to it, this contract is broken. Therefore, <code>array</code> can not accept <code>array&lt;int&gt;</code>.</p>

<p>Invariance would make arrays very difficult to adopt, as a library can not start type hinting generic arrays without breaking user code, and users can not pass generic arrays to libraries until they start using generic arrays type declarations.</p>

<p>These pitfalls are why it may also be preferable to focus on object-based collections. Either with the custom syntax above described as Collections, or with the more complete full generics, as are present in most modern languages.  However, the two approaches are mutually-compatible.</p>

<h1 id="conclusion">Conclusion</h1>

<p>We hope to have explained in this article what different options are available for the implementation of generic objects, collections, or related features into PHP. More work is required, and ongoing, to determine which options are most desireable, or even feasible.</p>

<p>The next steps for investigation are:</p>

<ul>
<li>Further investigate type inference for reified generics.  If that turns out to be feasible with acceptable trade-offs, that is most likely the best option, and would imply building collections on top of them.</li>
<li>Determine if erased generics would have any additional drawbacks not noted here that would make them infeasible.</li>
<li>Determine if fully-erased types would have additional drawbacks not noted here that would make them infeasible.</li>
<li>Further develop an optimal feature set for collections, which would be applicable either in the dedicated syntax or as an application of generics (reified or erased).</li>
<li>Investigate the feasibility of using internal data structures in collections other than a hashmap (array) for better performance and simplicity.  (This would be a reason collections could not be done fully in user-space.)</li>
<li>Halt efforts on typed arrays, as our current thoughts are that it is probably not worth doing, due to the complexities of how arrays work, and the minimal functionality that it would bring.</li>
</ul>

<p>Right now, we’re focused on gathering feedback specifically related to the questions below, to help guide our next steps:</p>

<ul>
<li>If reified generics turn out to be infeasible, would erased generics be acceptable, or should that continue to be left to user-space tooling?</li>
<li>What generic features are acceptable to leave out to make the implementation more feasible?  (Eg, don't allow generics over union types; unioned generics are slow and we don't care; don't support in/out variance markers; etc.)</li>
<li>If erased generics are included, would that necessitate an official linter to validate them, or continue to leave that to user-space tooling?</li>
<li>If reified generics turn out to be infeasible, would the dedicated collections syntax shown here be acceptable?</li>
<li>Would "erased generics now, and we can <em>probably</em> convert them to reified in the future" be an acceptable strategy, if it is determined to be feasible?</li>
</ul>

<h1 id="discussions">Discussions</h1>

<ul>
<li><a href="https://externals.io/message/125049">PHP Internals mailing list</a></li>
<li><a href="https://www.reddit.com/r/PHP/comments/1ew7hik/state_of_generics_and_collections/">Reddit</a></li>
</ul>
]]></content><link href="https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections/"/><id>https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections/</id><updated>Mon, 19 Aug 2024 00:00:00 +0000</updated></entry><entry><author><name>Larry Garfield</name><uri>https://github.com/Crell</uri></author><title type="html"><![CDATA[PHP 8.5 Adds Pipe Operator: What it means]]></title><content type="html"><![CDATA[<p>PHP 8.5, due out November of this year, will bring with it another long-sought-after feature: the <a href="https://wiki.php.net/rfc/pipe-operator-v3">pipe operator</a> (<code>|&gt;</code>).  It's a small feature with huge potential, yet it still took years to happen.</p>

<h2 id="what-is-a-pipe-operator%3F">What is a pipe operator?</h2>

<p>The pipe operator, spelled <code>|&gt;</code>, is deceptively simple.  It takes the value on its left side and passes it as the single argument to a function (or in PHP's case, <code>callable</code>) on its right side:</p>

<pre><code class="php">$result = "Hello World" |&gt; strlen(...)

// Is equivalent to
$result = strlen("Hello World");
</code></pre>

<p>On its own, that is not all that interesting.  Where it becomes interesting is when it is repeated, or chained, to form a "pipeline."  For example, here's real code from a real project I've worked on, recast to use pipes:</p>

<pre><code class="php">$arr = [
  new Widget(tags: ['a', 'b', 'c']),
  new Widget(tags: ['c', 'd', 'e']),
  new Widget(tags: ['x', 'y', 'a']),
];

$result = $arr
    |&gt; fn($x) =&gt; array_column($x, 'tags') // Gets an array of arrays
    |&gt; fn($x) =&gt; array_merge(...$x)       // Flatten into one big array
    |&gt; array_unique(...)                  // Remove duplicates
    |&gt; array_values(...)                  // Reindex the array.
;

// $result is ['a', 'b', 'c', 'd', 'e', 'x', 'y']
</code></pre>

<p>The same code without pipes would require either this horribly ugly nest of evil:</p>

<pre><code class="php">array_values(array_unique(array_merge(...array_column($arr, 'tags'))));
</code></pre>

<p>Or manually creating a temporary variable for each step.  While temp variables are not the worst thing in the world, they are extra mental overhead, and mean that a chain like that cannot be used in a single-expression context, like a <code>match()</code> block.  A pipe chain can.</p>

<p>Anyone who has worked on the Unix/Linux command line will likely recognize the similarity to the shell pipe, <code>|</code>.  That's very deliberate, as it is effectively the same thing: Use the output from the left side as the input on the right side.</p>

<h2 id="where-did-it-come-from%3F">Where did it come from?</h2>

<p>The <code>|&gt;</code> operator appears in many languages, mostly in the functional world.  F# has essentially the exact same operator, as does OCaml.  Elixir has a slightly fancier version (which we considered but ultimately decided against for now).  Numerous PHP libraries exist in the wild that offer similar capability with many extra expensive steps, including my own <a href="https://github.com/Crell/fp/">Crell/fp</a>.</p>

<p>The story for PHP pipes, though, begins with Hack/HHVM, Facebook's PHP fork née competitive implementation.  Hack included many features beyond what PHP 5 of the day offered; many of them eventually ended up in later PHP versions.  One of its features was a unique spin on a pipe operator.</p>

<p>In 2016, Sara Golemon, long-time PHP contributor and former Open Source lead on the HHVM project, proposed porting <a href="https://wiki.php.net/rfc/pipe-operator">Hack's pipes</a> to PHP directly.  In that RFC, the right side of a pipe wasn't a <code>callable</code> but an expression, and used a magic <code>$$</code> token (lovingly called <code>T_BLING</code>, at least according to yours truly) to inject the left-side result into it.  In that case, the example above would look like this:</p>

<pre><code class="php">$result = $arr
    |&gt; array_column($$, 'tags')
    |&gt; array_merge(...$$)
    |&gt; array_unique($$)
    |&gt; array_values($$)
;
</code></pre>

<p>While powerful, it was also somewhat limiting.  It was very non-standard, unlike any other language.  It also meant a weird, one-off syntax for partially-calling functions that worked only when paired with pipes.</p>

<p>That RFC didn't go as far as a vote.  Nothing much happened for several years, until 2020/2021.  That's when I, fresh off of writing a book on functional programming in PHP that talked about function composition, decided to take a swing at it.  In particular, I partnered with a team to work on <a href="https://wiki.php.net/rfc/partial_function_application">Partial Function Application</a> (PFA) as a separate RFC from a more <a href="https://wiki.php.net/rfc/pipe-operator-v2">traditional pipe</a>.  The idea was that turning a multi-parameter function (like <code>array_column()</code> above) into the single-parameter function that <code>|&gt;</code> needed was a useful feature on its own, and should be usable elsewhere.  The syntax was a bit different than the Hack version, in order to make it more flexible: <code>some_function(?, 5, ?, 3, ...)</code>, which would take a 5-or-more parameter function and turn it into a 3 parameter function.</p>

<p>Sadly, PFA didn't pass due to some engine complexity issues, and that largely undermined the v2 Pipe RFC, too.  However, we did get a consolation prize out of it: <a href="https://wiki.php.net/rfc/first_class_callable_syntax">First Class Callables</a> (the <code>array_values(...)</code> syntax), courtesy Nikita Popov, were by design a "junior", degenerate version of partial function application.</p>

<p>Fast-forward to 2025, and I was sufficiently bored to take another swing at pipes.  This time with a better implementation with lots of hand-holding from Ilija Tovilo and Arnaud Le Blanc, both part of the PHP Foundation dev team, I was able to get it through.</p>

<p>Third time's the charm.</p>

<h2 id="more-than-the-sum-of-its-parts">More than the sum of its parts</h2>

<p>Above, we described pipes as "deceptively simple."  The implementation itself is almost trivial; it's just syntax sugar for the temp variable version, effectively.  However, the best features are the ones that can combine with others or be used in novel ways to punch above their weight.</p>

<p>We saw above how a long array manipulation process could now be condensed into a single chained expression.  Now imagine using that in places where only a single expression is allowed, such as a <code>match()</code>:</p>

<pre><code class="php">$string = 'something GoesHERE';

$newString = match ($format) {
    'snake_case' =&gt; $string
        |&gt; splitString(...)
        |&gt; fn($x) =&gt; implode('_', $x)
        |&gt; strtolower(...),
    'lowerCamel' =&gt; $string
        |&gt; splitString(...),
        |&gt; fn($x) =&gt; array_map(ucfirst(...), $x)
        |&gt; fn($x) =&gt; implode('', $x)
        |&gt; lcfirst(...),
    // Other case options here.
};
</code></pre>

<p>Or, consider that the right-side can also be a function call that returns a <code>Closure</code>.  That means with a few functions that return functions:</p>

<pre><code class="php">$profit = [1, 4, 5] 
    |&gt; loadSeveral(...)
    |&gt; filter(isOnSale(...))
    |&gt; map(sellWidget(...))
    |&gt; array_sum(...);
</code></pre>

<p>Which... gives us mostly the same thing as the long-discussed scalar methods!  Only pipes are more flexible as you can use any function on the right-side, not just those that have been blessed by the language designers as methods.</p>

<p>At this point, pipe comes very close to being "extension functions", a feature of Kotlin and C# that allows writing functions that look like methods on an object, but are actually just stand-alone functions.  It's spelled a bit differently (<code>|</code> instead of <code>-</code>), but it's 75% of the way there, for free.</p>

<p>Or take it a step further.  What if some steps in the pipe may return <code>null</code>?  We can, with a single function, "lift" the elements of our chain to handle <code>null</code> values in the same fashion as null-safe methods.</p>

<pre><code class="php">function maybe(\Closure $c): \Closure
{
    return fn(mixed $arg) =&gt; $arg === null ? null : $c($arg);
}

$profit = [1, 4, 5] 
    |&gt; maybe(loadSeveral(...))
    |&gt; maybe(filter(isOnSale(...)))
    |&gt; maybe(map(sellWidget(...)))
    |&gt; maybe(array_sum(...));
</code></pre>

<p>That's right, we just implemented a Maybe Monad with a pipe and a single-line function.</p>

<p>Now, think about that for streams...</p>

<pre><code class="php">fopen('pipes.md', 'rb') // No variable, so it will close automatically when GCed.
    |&gt; decode_rot13(...)
    |&gt; lines_from_charstream(...)
    |&gt; map(str_getcsv(...))
    |&gt; map(Product::create(...))
    |&gt; map($repo-&gt;save(...))
;
</code></pre>

<p>The potential is absolutely huge.  I don't think it's immodest to say that the pipe operator has one of the highest "bangs for the buck" of any feature in recent memory, alongside such niceties as constructor property promotion.  And all thanks to a little syntax sugar.</p>

<h2 id="what-comes-next%3F">What comes next?</h2>

<p>Although pipes are a major milestone, we're not done.  There is active work on not one but two follow-up RFCs.</p>

<p>The first is a second attempt at <a href="https://wiki.php.net/rfc/partial_function_application_v2">Partial Function Application</a>.  This is a larger feature, but with first-class callables already bringing in much of the necessary plumbing, which simplifies the implementation.  With pipes now providing a natural use case, as well as easy optimization points, it's worth a second attempt.  Whether it makes it into PHP 8.5, is delayed to 8.6, or is again rejected is still an open question as of this writing, though I am hopeful.  Major thanks to Arnaud Le Blanc from the PHP Foundation team for picking it up to update the implementation.</p>

<p>The second is a <a href="https://wiki.php.net/rfc/function-composition">function composition operator</a>.  Where pipe executes immediately, function composition creates a new function by sticking two functions end-to-end.  That would mean the streams example above could be further optimized by combining the <code>map()</code> calls:</p>

<pre><code class="php">fopen('pipes.md', 'rb')
    |&gt; decode_rot13(...)
    |&gt; lines_from_charstream(...)
    |&gt; map(str_getcsv(...) + Product::create(...) + $repo-&gt;save(...))
;
</code></pre>

<p>This one is definitely not going to make it into PHP 8.5, but I am hopeful that we'll be able to get it into 8.6.  Stay tuned.</p>

<blockquote>
  <p>Special thanks to Ilija Tovilo and Arnaud Le Blanc from the PHP Foundation team for their assistance with the pipe implementation.  If you’d like to help push PHP forward, consider <a href="https://thephp.foundation/sponsor/">becoming a sponsor</a>.</p>
</blockquote>
]]></content><link href="https://thephp.foundation/blog/2025/07/11/php-85-adds-pipe-operator/"/><id>https://thephp.foundation/blog/2025/07/11/php-85-adds-pipe-operator/</id><updated>Fri, 11 Jul 2025 00:00:00 +0000</updated></entry></feed>
