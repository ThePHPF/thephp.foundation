<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title><![CDATA[The PHP Foundation]]></title><description><![CDATA[Supporting, Advancing, and Developing the PHP Language]]></description><updated>2025-10-30T15:12:07+00:00</updated><entry><author><name>Jakub Zelenka</name><uri>https://github.com/bukka</uri></author><title type="html"><![CDATA[Introducing Web&nbsp;Services&nbsp;Tool for&nbsp;PHP-FPM]]></title><content type="html"><![CDATA[<p>The Web Services Tool (WST) is a command-line application developed to test PHP-FPM, <a href="https://www.sovereigntechfund.de/tech/php"><strong>commissioned by the Sovereign Tech Fund</strong></a> (STF). Its primary goal is to facilitate testing of the integration between different web servers and PHP-FPM across various environments and configurations.</p>

<p>This blog post provides an introduction to the tool. We'll go through the history of PHP-FPM testing and the reasons that led to WST's development. The post also outlines the project structure, insights into the tool‚Äôs architecture, its current state, and the roadmap for future development.</p>

<h2 id="php-fpm-testing-and-wst-history">PHP-FPM testing and WST history</h2>

<h3 id="first-steps">First steps</h3>

<p>PHP-FPM was initially developed as a patch series starting around 2004. It evolved into a more modular architecture with a separate SAPI by 2009, and it was <a href="https://github.com/php/php-src/commit/06b9943842eb954025ac83b542e97d6310aa524a">merged into the PHP core</a> in 2010. It was declared stable with the release of PHP 5.4 in 2011. While this version introduced many features that are still used today, it did not include any automated tests; all testing was done manually.</p>

<p>The first automated test was introduced in early 2014, and it provided a basic check to verify that PHP-FPM can start with a certain configuration. Later that year, more advanced tests were added, including a FastCGI client, which allowed PHP-FPM to run in a separate process, accept FastCGI requests, and return responses. This was a major step forward, as it enabled testing scenarios that weren't previously possible. However, the implementation was more of a workaround, piecing together different components. The tests were repetitive and limited in their ability to define complex expectations.</p>

<h3 id="a-bit-more%2C-but-still-not-enough">A bit more, but still not enough</h3>

<p>In 2018, I <a href="https://github.com/php/php-src/commit/ea592e6b6c43b7c5ebedf63254b8088f741e276c">carried out</a> a complete rewrite of the FPM tests, introducing a primary <code>Tester</code> class. This class integrated more robust expectations and added abstractions for handling requests and responses. Over the years, this framework has been improved and now includes many features that support testing more complex scenarios. It significantly improves test code re-usability and offers various new options for easier testing. However, it <strong>doesn‚Äôt cover integration tests with web servers</strong>, which often have quirks not easily caught by these tests. Additionally, this framework <strong>doesn't handle high-load scenarios</strong>, which are necessary for testing process management in PHP-FPM. <strong>This showed the need for a new tool to keep PHP-FPM development safe.</strong></p>

<h3 id="here-comes-the-php-foundation-and-the-stf-service-agreement">Here comes The PHP Foundation and the STF service agreement</h3>

<p>Initially, I had an idea to extend <a href="https://github.com/bukka/fpmt">fpmt</a>, my tool for testing PHP-FPM (specifically for sending custom FastCGI requests), and integrate most of the testing logic directly into it. However, it soon became clear that maintaining such a tool would require constant code changes, and the effort needed to build and sustain it was too large. As a result, I put the project on hold.</p>

<p>It wasn‚Äôt until 2023 that the idea resurfaced, thanks to an opportunity provided by the Sovereign Tech Fund. The STF gave PHP projects a chance to propose initiatives aimed at improving their overall health. Testing, being a critical component of project health, made this tool a perfect candidate, and it, along with <a href="https://www.sovereigntechfund.de/tech/php#what-are-we-funding">three other projects</a>, comprised the scope of work commissioned by the STF.</p>

<h3 id="how-wst-started">How WST started</h3>

<p>I began the work on the tool in January 2024 with the planning phase. It quickly became evident that a more generic approach would offer greater flexibility and cover more use cases. I decided to design the tool around a clear configuration structure, which would be parsed and executed. A key part of the planning was ensuring that the <strong>same tests could run both locally and in containers</strong>, with an option to simulate high loads by integrating with a load testing tool. Given these requirements, I chose Go as the implementation language, as it provides well-supported clients and packages for all the project‚Äôs needs. Go's advanced templating capabilities, which are popular in tools like Helm, were also a deciding factor.</p>

<p>For easier setup, the project was organized under a new <a href="https://github.com/wstool/"><strong>wstool</strong></a> organization, containing two repositories: one for the actual tool implementation (<a href="https://github.com/wstool/wst">wst</a>) and another for the PHP-FPM testing configurations (<a href="https://github.com/wstool/wst-php-fpm">wst-php-fpm</a>). The structure of the application differs slightly from typical Go applications, as it focuses on achieving full test coverage for most components. As a result, it features multiple sub-packages to allow for the creation of mocks using <a href="https://github.com/vektra/mockery">Go Mockery</a>, which generates <a href="https://github.com/stretchr/testify">Testify</a> mocks.</p>

<h2 id="the-current-state-and-its-structure">The current state and its structure</h2>

<p>The tool has been developed into a functional state that allows it to run various tests. Its architecture is defined by its configuration, with a strong emphasis on flexibility.</p>

<p>At the core of the configuration is a file that contains a specification composed of settings for various components. Multiple configuration files can be specified, along with specific overrides for selected values. These configurations and overrides are then merged into a single, unified configuration. Example of execution could look like:</p>

<pre><code class="shell">wst -f /path/to/cfg1 -f /path/to/cfg2 -o spec.defaults.service.sandbox=docker
</code></pre>

<p>This will merge cfg1 and cfg2 and apply overwrite for the default server.<br />
The final configuration defines environments, sandboxes, servers, and instances ‚Äì these are the core elements of the application‚Äôs execution. Additionally, it defines some default settings, including base parameters. These parameters allow for further customization and can be accessed within template files and strings. The example of primary configuration looks like</p>

<pre><code class="yaml">version: "0.1"
name: FPM
description: FPM server specifications for testing PHP-FPM
spec:
  environments: environments.yaml
  instances: spec/instances/*.yaml
  sandboxes: sandboxes.yaml
  servers: servers/*/*/server.yaml
  workspace: workspace/
  defaults:
    service:
      sandbox: local
    parameters:
      fpm_binary: php-fpm
</code></pre>

<p>As you can see, it is possible to separate config to multiple files that can be specified in the wildcard format. The meaning of primary spec parts is following:</p>

<ul>
<li><p><strong>Environments</strong> specify where the tests are executed, allowing for tests to run locally, in Docker, or Kubernetes environments. This enables testing across different distributions using Docker and under production-like loads with Kubernetes. Such flexibility helps recreate reported issues more effectively, as some problems only appear under heavy load. It also provides greater confidence when implementing new features or fixing complex bugs.</p></li>
<li><p><strong>Sandboxes</strong> are closely related to environments, defining how services behave in each environment. Specifically, they define hooks containing commands or signals for starting, stopping, reloading, and restarting services.</p></li>
<li><p><strong>Servers</strong> contain the specifications of the web servers or other web services being tested. They define server configuration templates, expectations, parameters, and specific hooks linked to sandboxes. For instance, a server might specify PHP-FPM configuration files (fpm.conf, php.ini), set up start hooks for the PHP-FPM binary with selected parameters, and outline specific log message expectations following PHP-FPM startup. These predefined settings help reduce code duplication.</p></li>
<li><p><strong>Instances</strong> are the core of WST‚Äôs testing functionality. They define everything specific to a single test case, primarily specifying the service. This means choosing the server by name, providing parameters, and specifying configuration files to be included with the selected parameters. They also define scripts included in the services and their content, which are then utilized during actions.</p></li>
</ul>

<p>The mentioned actions offer additional flexibility by providing a custom mini pipeline which offers a high degree of flexibility. Actions are responsible for controlling services (start, stop, restart, reload), triggering requests (request, bench), and setting expectations on output (logs), responses (for requests), and metrics (for benchmarks). There is also a parallel action, allowing multiple actions to run simultaneously</p>

<p>This is an example of a simple instance with actions:</p>

<pre><code class="yaml">version: "0.1"
name: FPM
description: FPM server specifications for testing PHP-FPM
spec:
  environments: environments.yaml
  instances: spec/instances/*.yaml
  sandboxes: sandboxes.yaml
  servers: servers/*/*/server.yaml
  workspace: workspace/
  defaults:
    service:
      sandbox: local
    parameters:
      fpm_binary: php-fpm
</code></pre>

<p>This test starts FPM and <code>httpd</code> with selected configs, sends a request for <code>index.php</code> path, verifies that response body and stops the servers.</p>

<p>Currently, the tool works in a local environment and has already helped recreate complex scoreboard locking issues through its automated load testing (bench action). The Docker and Kubernetes environments have largely been finalized in terms of structure, with most of the implementation in place. However, some additional changes and fixes are needed for full functionality.</p>

<h2 id="the-first-results">The first results</h2>

<p>The initial PHP-FPM configuration includes only a few instances and server configurations. It defines three servers‚Äîfpm, nginx, and httpd (Apache). These servers contain default configurations with all necessary settings, as well as variants for Debian and RedHat that could be used as needed. The servers also define reusable expectations across instances. For PHP-FPM, these expectations are used to verify that the server has started successfully, based on log messages, and include templates for asserting FPM status responses.</p>

<p>As for instances, there are currently the following tests defined:</p>

<ul>
<li><a href="https://github.com/wstool/wst-php-fpm/blob/bccec57f02e7918aedf5bce43387a3c1ce733f37/spec/instances/access-suppress-path-status.yaml">Access log path suppression test</a> &#45; It verifies access logs, which uses status checking and output verification to ensure that access logs are properly generated in both PHP-FPM and Nginx.</li>
<li><a href="https://github.com/wstool/wst-php-fpm/blob/bccec57f02e7918aedf5bce43387a3c1ce733f37/spec/instances/httpd-proxy-fcgi-handler-basic.yaml">Apache httpd mod&#95;proxy&#95;fcgi SetHandler basic tests</a> &#45; It tests FastCGI integration between Apache httpd and PHP-FPM and makes sure that different combinations of test works. It also recreates a recent issue with Apache httpd integration.</li>
<li><a href="https://github.com/wstool/wst-php-fpm/blob/bccec57f02e7918aedf5bce43387a3c1ce733f37/spec/instances/scoreboard-atomic-copy.yaml">Scoreboard atomic copying test</a> &#45; It focuses on testing the scoreboard under higher loads. This test has been particularly useful in reliably reproducing a scoreboard locking issue, which has been causing errors for users. Once the issue is resolved, the test will serve as a regression check to ensure the problem doesn‚Äôt reoccur.</li>
</ul>

<h2 id="the-future-development">The future development</h2>

<p>The primary goal moving forward is to add more tests and begin using the tool to address existing complex issues and features in PHP-FPM. This will require further updates to the application to improve its capabilities. The tool also needs to be stabilized and made more user-friendly, specifically, enhancing logging and documentation.</p>

<p>Once the tool and PHP-FPM tests reach a stable state, the next step would be to set up a continuous integration (CI) system to run all stable tests regularly against the latest repository. Ideally, this could be integrated into PHP‚Äôs nightly workflow. There is a possibility to use higher spec resources from TeamCity or infrastructure provided by AWS to PHP Foundation which is currently used for benchmarking project testing performance of PHP.</p>

<p>Since the tool is not specific to PHP-FPM, it could also be applied to other parts of PHP. For example, it could finally enable tests for the Apache handler (<code>mod_php</code>) SAPI, which is still widely used but currently lacks testing, making changes risky. Additionally, the tool could be useful for testing specific scenarios involving PHP extensions that rely on external services, such as databases or LDAP.</p>

<p>Another area where the tool could be valuable is in performing various security-related tests. Adding fuzzing capabilities could help uncover a range of issues, including potential security vulnerabilities, not only in PHP-FPM but also in the web servers themselves.</p>

<p>Testing full framework applications and automating setup steps like <code>composer install</code> could improve the tool as well. This will require more time and help from the community to make sure the setups are reliable in all environments.</p>

<h2 id="summary">Summary</h2>

<p>The WST has already proven to be valuable for PHP-FPM development and testing, because it helps address  complex issues which were never tested in automated way before.</p>

<p>As more features and tests are added, its importance will only grow. We hope it will become an essential part of ensuring PHP-FPM's stability, performance, and evolution.</p>

<p>üíúÔ∏è üêò</p>
]]></content><link href="https://thephp.foundation/blog/2024/10/21/web-services-tool-for-php-fpm/"/><id>https://thephp.foundation/blog/2024/10/21/web-services-tool-for-php-fpm/</id><updated>Mon, 21 Oct 2024 00:00:00 +0000</updated></entry><entry><author><name>Jakub Zelenka</name><uri>https://github.com/bukka</uri></author><title type="html"><![CDATA[Evolving PHP Streams for Async, Security, and Performance]]></title><content type="html"><![CDATA[<p>Thanks to investment from the <strong><a href="https://www.sovereign.tech/">Sovereign Tech Agency (STA)</a></strong>, a German government backed organization supporting open-source infrastructure, the PHP Foundation is modernizing one of PHP‚Äôs oldest and most critical subsystems: Streams.</p>

<p>This post outlines the planned work and explains why these changes matter for the PHP ecosystem.</p>

<h2 id="what-are-php-streams%3F">What Are PHP Streams?</h2>

<p>Before diving into the improvements, let‚Äôs briefly revisit what Streams are and why they matter.</p>

<p>Introduced around 2001, PHP streams provide a unified way to handle file and network I/O, allowing data from different sources such as files, sockets, or memory to be accessed through a consistent API using the same set of functions.</p>

<p>Over time, PHP streams have proven to be a powerful and flexible subsystem, but some parts of the implementation have not evolved alongside modern use cases, performance expectations, and system capabilities. This project aims to make Streams faster, safer, and easier to extend for modern PHP applications.</p>

<p>The actual scope is divided into four subsections.</p>

<h2 id="performance-and-stability-improvements">Performance and Stability improvements</h2>

<p>This part aims to improve performance and consistency in how PHP Streams copying and seeking.</p>

<p>There is still room to improve performance in stream copying.</p>

<p>For example, copying large files or handling network transfers can be made faster through asynchronous I/O mechanisms like io_uring on Linux. At the same time, we need to prevent potential crashes caused by memory-mapped files. The goal is to phase out mmap usage and introduce a new copying API as part of the upcoming I/O API, using io_uring or other system features where available.</p>

<p>Seeking is currently problematic for filtered streams, which causes various inconsistencies. Developers working with filters often encounter limitations when rewinding or skipping data.</p>

<p>The plan is to introduce a new seeking filter API that will allow seeking in streams where possible and disallow it where not. For example, seeking to the beginning should always be possible, but not all filters support seeking to arbitrary positions. Some may allow it, so a new internal API is needed.</p>

<h2 id="error-handling-and-monitoring-enhancements">Error Handling and Monitoring Enhancements</h2>

<p>This part is mainly about the introduction of new error reporting mechanisms for streams as well as the introduction of more hooks. Currently, many low-level I/O errors are surfaced inconsistently to user space. The goal is to standardize how Streams report errors and make them easier to debug.</p>

<p>The primary idea for error reporting is to have a better way to handle errors so they can be collected and reported to user space. We‚Äôll wrap existing errors and provide richer context options for developers.</p>

<p>In terms of hooks, this would be useful for async code and could be done through a special polling wrapper. There should be some way to allow replacing some blocking operations (specifically for file IO). This is primarily meant as an internal change, but it will also be considered to possibly expose some hooks to user space if convenient and acceptable from a performance point of view.</p>

<h2 id="networking-and-socket-improvements">Networking and Socket Improvements</h2>

<p>This part is mainly about the introduction of a new polling API, improvements in the stream_select function, and resolving issues in socket handling.</p>

<p>Modern network applications rely heavily on scalable event handling. The new polling API will introduce modern mechanisms such as epoll and kqueue, enabling PHP to handle multiple I/O streams more efficiently.</p>

<p>Currently, only select is available for user space, which has known performance and scaling issues. This modernization will benefit frameworks and extensions that implement async networking or event-driven I/O.</p>

<p>The purpose of the API is primarily to build an internal API that can be used internally for various tasks in the PHP core and as a base (fallback) for the future async IO API.</p>

<p>The stream_select usage should be extended to better handle polling of filtered streams and provide an API for external objects that can provide extra data, as will be possible in the new polling API. This will require some refactoring and potentially sharing some of the logic with the new polling API.</p>

<p>Additionally, several socket-specific improvements are planned. New socket context options will be added to provide better configuration capabilities. Various socket handling issues will be addressed, and utilities for working with file descriptors will be improved.</p>

<h2 id="security-and-tls-enhancements">Security and TLS Enhancements</h2>

<p>Another important part of this work targets the OpenSSL extension, which handles encrypted streams.</p>

<p>Specifically, refactoring its async handling that is currently not well implemented and has various limitations. The refactoring will clarify what polling action is required for user space. For example, whether the stream needs to wait for reading or writing.</p>

<p>In addition, we aim to improve TLS 1.3 support with options to select cipher suites and integrate TLS Sessions, PSK (Pre-Shared Key) and early data (0-RTT) support.</p>

<p>To enable these changes, a new TLS 1.3 PHP testing library is being developed. It will allow customizing the protocol flow and testing TLS 1.3 features, including asynchronous behavior.</p>

<h2 id="next-steps">Next Steps</h2>

<p>Together, these efforts will modernize and strengthen PHP‚Äôs I/O layer for the next decade of web and CLI development.</p>

<p>Work has started in 2025 and will go through 2026. Incremental progress will be shared publicly through PHP Foundation updates and PHP internals discussions, and RFCs.</p>

<p>We‚Äôre grateful to the Sovereign Tech Agency for supporting this foundational investment in PHP‚Äôs core. Stay tuned for technical write-ups and benchmarks as the implementation progresses.</p>
]]></content><link href="https://thephp.foundation/blog/2025/10/30/php-streams-evolution/"/><id>https://thephp.foundation/blog/2025/10/30/php-streams-evolution/</id><updated>Thu, 30 Oct 2025 00:00:00 +0000</updated></entry></feed>
