<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[The PHP Foundation]]></title>
    <link href="https://thephp.foundation/atom.xml" rel="self"/>
    <link href="https://thephp.foundation/"/>
    <updated>2025-10-30T15:12:06+00:00</updated>
    <id>https://thephp.foundation/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Evolving PHP Streams for Async, Security, and Performance]]></title>
            <link href="https://thephp.foundation/blog/2025/10/30/php-streams-evolution/"/>
            <updated>2025-10-30T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/10/30/php-streams-evolution/</id>
            <content type="html"><![CDATA[<p>Thanks to investment from the <strong><a href="https://www.sovereign.tech/">Sovereign Tech Agency (STA)</a></strong>, a German government backed organization supporting open-source infrastructure, the PHP Foundation is modernizing one of PHP‚Äôs oldest and most critical subsystems: Streams.</p>

<p>This post outlines the planned work and explains why these changes matter for the PHP ecosystem.</p>

<h2 id="what-are-php-streams%3F">What Are PHP Streams?</h2>

<p>Before diving into the improvements, let‚Äôs briefly revisit what Streams are and why they matter.</p>

<p>Introduced around 2001, PHP streams provide a unified way to handle file and network I/O, allowing data from different sources such as files, sockets, or memory to be accessed through a consistent API using the same set of functions.</p>

<p>Over time, PHP streams have proven to be a powerful and flexible subsystem, but some parts of the implementation have not evolved alongside modern use cases, performance expectations, and system capabilities. This project aims to make Streams faster, safer, and easier to extend for modern PHP applications.</p>

<p>The actual scope is divided into four subsections.</p>

<h2 id="performance-and-stability-improvements">Performance and Stability improvements</h2>

<p>This part aims to improve performance and consistency in how PHP Streams copying and seeking.</p>

<p>There is still room to improve performance in stream copying.</p>

<p>For example, copying large files or handling network transfers can be made faster through asynchronous I/O mechanisms like io_uring on Linux. At the same time, we need to prevent potential crashes caused by memory-mapped files. The goal is to phase out mmap usage and introduce a new copying API as part of the upcoming I/O API, using io_uring or other system features where available.</p>

<p>Seeking is currently problematic for filtered streams, which causes various inconsistencies. Developers working with filters often encounter limitations when rewinding or skipping data.</p>

<p>The plan is to introduce a new seeking filter API that will allow seeking in streams where possible and disallow it where not. For example, seeking to the beginning should always be possible, but not all filters support seeking to arbitrary positions. Some may allow it, so a new internal API is needed.</p>

<h2 id="error-handling-and-monitoring-enhancements">Error Handling and Monitoring Enhancements</h2>

<p>This part is mainly about the introduction of new error reporting mechanisms for streams as well as the introduction of more hooks. Currently, many low-level I/O errors are surfaced inconsistently to user space. The goal is to standardize how Streams report errors and make them easier to debug.</p>

<p>The primary idea for error reporting is to have a better way to handle errors so they can be collected and reported to user space. We‚Äôll wrap existing errors and provide richer context options for developers.</p>

<p>In terms of hooks, this would be useful for async code and could be done through a special polling wrapper. There should be some way to allow replacing some blocking operations (specifically for file IO). This is primarily meant as an internal change, but it will also be considered to possibly expose some hooks to user space if convenient and acceptable from a performance point of view.</p>

<h2 id="networking-and-socket-improvements">Networking and Socket Improvements</h2>

<p>This part is mainly about the introduction of a new polling API, improvements in the stream_select function, and resolving issues in socket handling.</p>

<p>Modern network applications rely heavily on scalable event handling. The new polling API will introduce modern mechanisms such as epoll and kqueue, enabling PHP to handle multiple I/O streams more efficiently.</p>

<p>Currently, only select is available for user space, which has known performance and scaling issues. This modernization will benefit frameworks and extensions that implement async networking or event-driven I/O.</p>

<p>The purpose of the API is primarily to build an internal API that can be used internally for various tasks in the PHP core and as a base (fallback) for the future async IO API.</p>

<p>The stream_select usage should be extended to better handle polling of filtered streams and provide an API for external objects that can provide extra data, as will be possible in the new polling API. This will require some refactoring and potentially sharing some of the logic with the new polling API.</p>

<p>Additionally, several socket-specific improvements are planned. New socket context options will be added to provide better configuration capabilities. Various socket handling issues will be addressed, and utilities for working with file descriptors will be improved.</p>

<h2 id="security-and-tls-enhancements">Security and TLS Enhancements</h2>

<p>Another important part of this work targets the OpenSSL extension, which handles encrypted streams.</p>

<p>Specifically, refactoring its async handling that is currently not well implemented and has various limitations. The refactoring will clarify what polling action is required for user space. For example, whether the stream needs to wait for reading or writing.</p>

<p>In addition, we aim to improve TLS 1.3 support with options to select cipher suites and integrate TLS Sessions, PSK (Pre-Shared Key) and early data (0-RTT) support.</p>

<p>To enable these changes, a new TLS 1.3 PHP testing library is being developed. It will allow customizing the protocol flow and testing TLS 1.3 features, including asynchronous behavior.</p>

<h2 id="next-steps">Next Steps</h2>

<p>Together, these efforts will modernize and strengthen PHP‚Äôs I/O layer for the next decade of web and CLI development.</p>

<p>Work has started in 2025 and will go through 2026. Incremental progress will be shared publicly through PHP Foundation updates and PHP internals discussions, and RFCs.</p>

<p>We‚Äôre grateful to the Sovereign Tech Agency for supporting this foundational investment in PHP‚Äôs core. Stay tuned for technical write-ups and benchmarks as the implementation progresses.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHP‚Äôs New URI Extension: An Open Source Success Story]]></title>
            <link href="https://thephp.foundation/blog/2025/10/10/php-85-uri-extension/"/>
            <updated>2025-10-10T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/10/10/php-85-uri-extension/</id>
            <content type="html"><![CDATA[<p>URLs are a fundamental building block of the Web we rely on every day.</p>

<p>Their familiarity makes them appear deceptively simple: Seemingly clearly
delineated components like scheme, hostname, path, and some others suggest that
it‚Äôs trivial to extract information from a URL. In reality, there are thousands
of custom parsers built over the years, each with their own take on details.</p>

<p>For us web developers, there are two main standards specifying how URLs are
supposed to work. <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a>,
which is the original URI standard from 2005; and the <a href="https://url.spec.whatwg.org/">WHATWG URL Living
Standard</a>, which is followed by web browsers.
Because things are not as simple as they appear at first glance, these two
commonly used standards are incompatible with each other&#33; Mixing and matching
different standards and their parsers, especially when they do not <em>exactly</em>
follow the standard, is something that <a href="https://daniel.haxx.se/blog/2022/01/10/dont-mix-url-parsers/">commonly leads to security
issues</a>.</p>

<h2 id="why-change-was-needed">Why Change Was Needed</h2>

<p>Despite the importance of correctly parsing URLs, PHP did not include any
standards-compliant parser within the standard library for the longest time.
There is the
<a href="https://www.php.net/manual/en/function.parse-url.php"><code>parse_url()</code></a> function,
which has existed since PHP 4, but it does not follow any standard and is
explicitly documented not to be used with untrusted or malformed URLs.
Nevertheless, it is commonly used for lack of a better alternative that is
readily available and also because it appears to work correctly for a majority
of well-formed inputs that developers encounter in day-to-day work. This can
mislead developers to believe that the security issues of <code>parse_url()</code> are a
purely theoretical problem rather than something that <em>will</em> cause issues
sooner or later.</p>

<p>As an example, the input URL <code>example.com/example/:8080/foo</code> is a valid URL
consisting of only a relative path according to RFC 3986&#46; It is invalid
according to the WHATWG URL standard when not resolved against a base URL.
However, according to <code>parse_url()</code> it is a URL for the host <code>example.com</code>,
port 8080 and path <code>/example/:8080/foo</code>, thus including the 8080 in <em>two</em> of
the resulting components:</p>

<pre><code class="php">&lt;?php

var_dump(parse_url('example.com/example/:8080/foo'));

/*
array(3) {
  ["host"]=&gt; string(11) "example.com"
  ["port"]=&gt; int(8080)
  ["path"]=&gt; string(18) "/example/:8080/foo"
}
*/
</code></pre>

<h2 id="introducing-a-new-api">Introducing a New API</h2>

<p>This changes with PHP 8.5. Going forward, PHP will include standards-compliant
parsers for both RFC 3986 and the WHATWG URL standard as an <em>always-available</em>
part of its standard library within a new ‚ÄúURI‚Äù extension. Not only will this
enable easy, correct, and secure parsing of URLs according to the respective
standard, but the URI extension also includes functionality to modify
individual components of a URL.</p>

<pre><code class="php">&lt;?php

use Uri\Rfc3986\Uri;

$url = new Uri('HTTPS://thephp.foundation:443/sp%6Fnsor/');

$defaultPortForScheme = match ($url-&gt;getScheme()) {
    'http' =&gt; 80,
    'https' =&gt; 443,
    'ssh' =&gt; 22,
    default =&gt; null,
};

// Remove default ports from URLs.
if ($url-&gt;getPort() === $defaultPortForScheme) {
    $url = $url-&gt;withPort(null);
}

// Getters normalize the URL by default. The `Raw`
// variants return the input unchanged.

echo $url-&gt;toString(), PHP_EOL;
// Prints: https://thephp.foundation/sponsor/
echo $url-&gt;toRawString(), PHP_EOL;
// Prints: HTTPS://thephp.foundation/sp%6Fnsor/
</code></pre>

<h2 id="thoughtfully-built-to-last">Thoughtfully Built to Last</h2>

<p>In this post we not only want to showcase the functionality but also tell you
the story of how this project developed and how work gets done in PHP to keep
the language modern and a great choice for web development. There is often more
work behind new PHP features than meets the eye. We hope to provide some
insight into why we prefer doing things right rather than fast.</p>

<p><a href="https://github.com/kocsismate">M√°t√© Kocsis</a> from The PHP Foundation‚Äôs dev team
initially started discussion for his <a href="https://wiki.php.net/rfc/url_parsing_api">RFC of a new URL parsing
API</a> in June 2024&#46; Given PHP‚Äôs
strong backwards compatibility promise, the new API needed to get things right
on the first attempt in order to serve the PHP community well for the decade to
come without introducing disruptive changes. Thus, over the course of <em>almost
one year</em>, <a href="https://news-web.php.net/php.internals/123997">more than 150 emails on the PHP Internals
list</a> were sent. Additionally,
several off-list discussions in various chat rooms have been had. Throughout
this process, various experts from the PHP community continuously refined the
RFC. They discussed even seemingly insignificant details, to provide not just a
standards-compliant implementation, but also a clean and robust API that will
guide developers towards the right solution for their use case. We also planned
ahead and made sure that the new URI extension with its dedicated <code>Uri</code>
namespace provides a clear path forward to add additional URI/URL-related
functionality in future versions of PHP.</p>

<p>The RFC ultimately went to vote in May 2025 and was accepted with a 30:1 vote.
But work didn‚Äôt stop there: The proposed API also had to be implemented and
reviewed. Instead of building a PHP-specific solution, M√°t√© opted to stand on
the shoulders of giants and selected two libraries to perform the heavy
lifting. The <a href="https://uriparser.github.io/">uriparser library</a> provides the RFC
3986 parser, and the <a href="https://lexbor.com/">Lexbor library</a>, which is already
used by PHP 8.4‚Äôs new DOM API, provides the WHATWG parser.</p>

<h2 id="open-source-collaboration">Open Source Collaboration</h2>

<p>As part of the integration, M√°t√© and The PHP Foundation worked together with
the upstream maintainers to include missing functionality in the respective
libraries. As an example, neither library included functionality to cheaply
duplicate the internal data structures, which was necessary to support cloning
the readonly PHP objects representing the parsed URL when attempting to modify
individual components with the so-called with-er methods (e.g.,
<code>-&gt;withPort(8080)</code>). The uriparser library also did not include any functions
for modifying components of a parsed URL. All this functionality is now
available in the upstream libraries for everyone to use and benefit from.</p>

<p>The review and testing of M√°t√©‚Äôs PHP implementation was carried out by PHP
community contributors <a href="https://github.com/nielsdos/">Niels Dossche</a> and
<a href="https://github.com/nyamsprod/">Ignace Nyamagana Butera</a>. This included
reviewing and testing the new functionality that had been added to the two
upstream libraries. <a href="https://thephp.foundation/#sponsors_silver">Tideways, a founding member and Silver
sponsor</a> of The PHP Foundation,
also sponsored engineering time; their contribution came in the form of <a href="https://github.com/TimWolla/">Tim
D√ºsterhus</a>. During the review and testing, these
reviewers discovered several pre-existing bugs in the upstream libraries. They
submitted fixes to the upstream maintainers, <a href="https://github.com/hartwork">Sebastian
Pipping</a> (uriparser) and <a href="https://github.com/lexborisov">Alexander
Borisov</a> (Lexbor), who quickly reviewed and
applied them.</p>

<h2 id="test-it-now">Test It Now</h2>

<p>This work paid off, and PHP‚Äôs new URI extension with not just one but two
feature-rich and standards-compliant URI implementations is fully available for
testing with PHP 8.5 RC 1&#46;</p>

<p>If you'd like to see further improvements to PHP‚Äôs standard library please
consider <a href="https://thephp.foundation/sponsor/">sponsoring The PHP Foundation</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Call for Designs: Refresh the PHP 8.5 Release Page]]></title>
            <link href="https://thephp.foundation/blog/2025/10/01/design-contest/"/>
            <updated>2025-10-01T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/10/01/design-contest/</id>
            <content type="html"><![CDATA[<div class="flex justify-center mb-4">
    <a href="https://x.com/pronskiy/status/1877672616355340392" target="_blank" rel="noopener noreferrer"><img src="/assets/post-images/2025/website_redesign.png" width="500" alt="Website Redesign Twitter" class="shadow-md rounded-lg"/></a>
</div>

<p>Redesign <a href="https://www.php.net/">php.net</a>? We hear you. Let‚Äôs start small and ship something great: a refreshed PHP 8.5 release page. The <a href="https://externals.io/message/112026#112026">8.0-era page</a> built with community contributors and <a href="https://www.jetbrains.com/?utm_source=thephp.foundation&amp;utm_medium=referral&amp;utm_campaign=phpstorm&amp;utm_content=refreshing-php-release-webpage">JetBrains</a> set the tone for 8.x. It‚Äôs held up, but 8.5 is a good moment to modernize: modern, clean, fast, inspiring.</p>

<p>We‚Äôre opening a design contest and you, the community, will help choose the winner. Read on for how to enter.</p>

<h2 id="prizes">Prizes</h2>

<ul>
<li><strong>ü•á Grand prize: USD $1,000 sponsored by JetBrains</strong></li>
<li>Honorable mentions (credit in the footer of the page)</li>
</ul>

<h2 id="what-we%E2%80%99re-looking-for">What we‚Äôre looking for</h2>

<p>A modern, lightweight design for the PHP 8.5 release page that:</p>

<ul>
<li>Keeps things simple: vanilla HTML/CSS, minimal/no JS, <strong>no new build tools or frameworks</strong>.</li>
<li>Mobile-first &amp; fast: responsive layouts, small assets, system fonts.</li>
<li>Localizable: works with multiple languages, avoids text baked into images.</li>
<li>Content-first: use existing <a href="https://github.com/php/web-php/pull/1454">8.5 content</a> as data.</li>
<li>On-brand: feels at home on php.net; tasteful, unobtrusive visuals.</li>
<li>Maintainable: straightforward markup that future contributors can edit.</li>
</ul>

<p>Nice-to-have: a visual approach that can evolve for future releases (e.g., PHP 9.x).</p>

<h2 id="what-to-submit">What to submit</h2>

<p>Please submit designs first (we‚Äôre not judging big code drops):</p>

<ul>
<li>Mockups or prototype (Issue to <a href="https://github.com/php/web-php/issues/new?template=design-contest.yml">php/web-php</a>).</li>
<li>A short rationale (why this layout, how it meets the criteria).</li>
<li>You can also link to PR with the implementation.<br />
Keep the code small and clean. We won‚Äôt review large generated codebases.</li>
</ul>

<h2 id="how-to-submit">How to submit</h2>

<p>Create a GitHub Issue in the <a href="https://github.com/php/web-php">php/web-php</a> repository using <a href="https://github.com/php/web-php/issues/new?template=design-contest.yml">Design Contest template</a>:</p>

<div class="flex justify-center mb-4">
    <img width="600" src="/assets/post-images/2025/contest_issue.png" class="shadow-md rounded-lg"/>
</div>

<p>Include:</p>

<ul>
<li>Link(s) to mockups/prototype</li>
<li>3‚Äì5 screenshots (desktop/mobile)</li>
<li>Rationale (300‚Äì600 words)</li>
<li>Your name (and teammates, if any)</li>
</ul>

<p>See a pinned <a href="https://github.com/php/web-php/issues/1472">contest tracking issue</a> with all entries for easy browsing.</p>

<h2 id="timeline-utc">Timeline (UTC)</h2>

<ul>
<li>Submissions open: Oct 1, 2025</li>
<li>Deadline: Oct 22, 2025, 23:59</li>
<li>Shortlist announced: Oct 23, 2025</li>
<li>Community vote: Oct 23‚ÄìOct 30, 2025</li>
<li>Winner announced: Nov 1, 2025</li>
</ul>

<h2 id="how-we%E2%80%99ll-pick-the-winner">How we‚Äôll pick the winner</h2>

<ul>
<li>Jury (40%): php.net maintainers Sergey, Luffy, Derick, Sara + design advisor <a href="https://www.linkedin.com/in/sergei-ellin/">Sergei Elin</a> (JetBrains) evaluate against the criteria below.</li>
<li>Community vote (60%): single-vote mechanism.</li>
<li>Tie-breaker: jury decision.</li>
</ul>

<p>Scoring criteria:</p>

<ol>
<li>Clarity of content hierarchy</li>
<li>Responsiveness &amp; mobile UX</li>
<li>Performance &amp; simplicity (no deps, readable markup)</li>
<li>Fit with php.net look and tone</li>
</ol>

<h2 id="rules-%26-licensing">Rules &amp; licensing</h2>

<ul>
<li>Your submission must be your original work and free of restrictive third-party licenses.</li>
<li>By entering, you agree your design (and any code you provide) will be licensed under the <a href="https://php.net/copyright.php">same terms as the php.net</a> website (web-php repository) and may be adapted as needed.</li>
<li>Team entries are allowed (max 1 entry per person/team).</li>
<li>Judges and organizers cannot participate.</li>
<li>We may decline to award if no entry meets the bar.</li>
<li>Participants must be 18 years or older.</li>
<li>Submissions from participants in restricted or sanctioned territories will not be considered.</li>
</ul>

<h2 id="questions">Questions</h2>

<p>Please ask in the pinned <a href="https://github.com/php/web-php/issues/1472">Contest issue</a> in <a href="https://github.com/php/web-php">php/web-php</a>. We‚Äôll keep answers centralized and public.</p>

<p>Let‚Äôs make the PHP 8.5 release page a joy to browse ‚Äì clear, fast, and friendly for everyone!</p>

<p>üêòüíú</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The PHP Foundation application form for 2026 is now open]]></title>
            <link href="https://thephp.foundation/blog/2025/09/30/application-form-2026/"/>
            <updated>2025-09-30T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/09/30/application-form-2026/</id>
            <content type="html"><![CDATA[<blockquote>
  <p>The PHP Foundation is a non-profit organization with a mission to support, advance, and develop the PHP language.</p>
  
  <p>Current major sponsors include JetBrains, Automattic, Sovereign Tech Agency, Laravel, GoDaddy.com, Private Packagist, Craft CMS, Zend by Perforce, Tideways, Symfony, Mercari Inc., Les-Tilleuls.coop, pixiv Inc., Aternos GmbH, Sentry, Cybozu, Manychat, and Passbolt.</p>
  
  <p>The foundation pays <a href="https://thephp.foundation/structure/#core_developers">11 developers</a> to work on the language. See what the foundation achieved in 2024 in the <a href="https://thephp.foundation/blog/2025/03/31/transparency-and-impact-report-2024/">Impact and transparency report</a>. You can also watch <a href="https://www.youtube.com/watch?v=2qTJgx2QF9M">Roman Pronskiy's video overview</a> of what the Foundation is working on.</p>
</blockquote>

<p>We're opening a regular round of applications for developer positions. We intend to decide on whom we will hire by the end of November. If selected, you would start your work January 1st, 2026.</p>

<p>The application form will be <strong>open until October 30, 2025</strong>.</p>

<p style="text-align: center;">
<a href="https://forms.gle/v9iTTRFwemRkZett7" class="inline-block py-2 no-underline px-6 !text-white bg-[#7f52ff] rounded-3xl hover:bg-[rgba(127,82,255,.8)]">Apply</a>
</p>

<div class="alert italic">
    <span class="inline-block font-bold">‚ö†Ô∏è Note: This is not a job for PHP developers or aspiring PHP developers.</span><br><br>
The development of <a href="https://github.com/php/php-src">the PHP core</a> is done in the –° programming language, and requires proficiency in system programming.
</div>

<h2 id="what-are-the-requirements%3F">What are the requirements?</h2>

<p>As before, we require experience in PHP core development. Ideally, you should have all, but at least some of the following:</p>

<ul>
<li>Pull-requests / commits to <a href="https://github.com/php/php-src">php/php-src</a></li>
<li>Experience in writing PHP extensions</li>
<li>Participation in PHP mailing lists</li>
<li>Contributions to other open-source projects</li>
</ul>

<h2 id="what-are-you-going-to-work-on%3F">What are you going to work on?</h2>

<p>Strategic areas we'd like you to work on:</p>

<ul>
<li>Performance</li>
<li>Security</li>
<li>Infrastructure</li>
<li>Web APIs (json, PDO, streams, etc.)</li>
</ul>

<p>This is not an exhaustive list. We encourage you to <strong>provide as detailed a description of what you want to work on as possible</strong>.</p>

<p>Our primary selection criterion is <strong>pragmatism</strong>. We place greater emphasis on solutions that improve the developer experience and benefit businesses that rely on PHP, rather than new syntax features.</p>

<p>Out of scope:</p>

<ul>
<li>Pure documentation works</li>
<li>Userland PHP packages</li>
<li>Websites</li>
<li>Translations</li>
</ul>

<h2 id="what-does-working-with-the-php-foundation-involve%3F">What does working with the PHP Foundation involve?</h2>

<p>Working for the PHP Foundation offers a lot of freedom, but it also requires discipline. Your work will roughly consist of the following:</p>

<ul>
<li>40% Triaging issues and fixing bugs</li>
<li>30% Working on strategic areas</li>
<li>20% Code reviews</li>
<li>&#62;10% Preparing RFCs and developing new language features</li>
</ul>

<p>As you can see, developing new RFCs is a fairly small part of the job. Most of the work is typical maintenance of an open-source project.</p>

<p>We are a fully distributed team. You can work from any place<strong>&#42;</strong> and at any time. All communication is asynchronous via Slack, GitHub, and Email. We meet for synchronous calls once a month.</p>

<p>Your work should be in line with the foundation's mission statement, and we expect you to follow <a href="https://thephp.foundation/code-of-conduct/">the code of conduct</a>.</p>

<blockquote>
  <p><strong>PHP Foundation Mission Statement</strong></p>
  
  <p>The PHP Foundation is a collective of people and organizations relying on the PHP language. Its mission is to ensure the long-term prosperity of the PHP language. The PHP Foundation focuses on providing financial support and guidance to PHP language developers to support its goals of improving the language for its users, providing high-quality maintenance, and improving the PHP language project to retain current contributors and to integrate new contributors. The PHP Foundation aims to promote the public image of the PHP language in the interest of retaining existing and gaining new users and contributors.</p>
</blockquote>

<p><em><strong>&#42;</strong> We do not consider applications from persons residing in sanctioned territories.</em></p>

<h2 id="how-to-apply%3F">How to apply?</h2>

<p>Submit your application now, and we will get back to you shortly. If you have any questions or suggestions, reach out to contact@thephp.foundation.</p>

<p style="text-align: center;">
<a href="https://forms.gle/v9iTTRFwemRkZett7" target="_blank" class="inline-block py-2 no-underline px-6 !text-white bg-[#7f52ff] rounded-3xl hover:bg-[rgba(127,82,255,.8)]">Open submission form</a>
</p>

<iframe src="https://docs.google.com/forms/d/e/1FAIpQLSeYNVQoK2r9c6EtoMnDaIpLzDc95egt1a1mcfiHTovqMDhFuw/viewform?embedded=true" width="100%" height="1866" frameborder="0" marginheight="0" marginwidth="0">Loading‚Ä¶</iframe>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Welcoming Joe Watkins as a PHP Foundation Developer]]></title>
            <link href="https://thephp.foundation/blog/2025/09/25/joe-watkins/"/>
            <updated>2025-09-25T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/09/25/joe-watkins/</id>
            <content type="html"><![CDATA[<p>We‚Äôre excited to share that Joe Watkins is joining the PHP Foundation as a contractor for the rest of 2025&#46;</p>

<p>Joe has helped <a href="https://blog.jetbrains.com/phpstorm/2021/11/the-php-foundation/">establish the PHP Foundation</a> in 2021 and is a long-time contributor to PHP core. He is known for his work on extensions like <a href="https://github.com/krakjoe/parallel">parallel</a> and <a href="https://github.com/krakjoe/pcov">PCOV</a> and most recently, he released <a href="https://krakjoe.github.io/ort/">ORT</a>, a blazing-fast ONNX runtime for PHP bringing native AI inference capabilities to PHP developers for the first time.</p>

<p>This decision comes outside our usual funding cycle, and it‚Äôs driven by two key factors:</p>

<ol>
<li><p><strong>Joe‚Äôs renewed health and momentum.</strong> While we initially planned to bring Joe on board in August 2024, his health at the time didn‚Äôt allow it. After reviewing our budget post-H1 2025 and realizing we had extra room, we saw an opportunity to support Joe‚Äôs return and enable him to contribute once again.</p></li>
<li><p><strong>The impact of his work.</strong> ORT is a concrete step toward making PHP more capable and future-proof. Beyond code, Joe has also contributed to the PHP process itself ‚Äî having proposed and championed several process-related RFCs over the years that helped shape how PHP evolves.</p></li>
</ol>

<p>Joe is contracted for a limited number of hours in H2 2025&#46; For 2026, he will be welcome to apply through our regular contributor funding process later this month, alongside others.</p>

<p>Here is what Joe has to say:</p>

<figure class="max-w-screen-md mx-auto text-center mb-6" id="quote-">
    <svg class="w-10 h-10 mx-auto mb-3 text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 18 14">
        <path d="M6 0H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4v1a3 3 0 0 1-3 3H2a1 1 0 0 0 0 2h1a5.006 5.006 0 0 0 5-5V2a2 2 0 0 0-2-2Zm10 0h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4v1a3 3 0 0 1-3 3h-1a1 1 0 0 0 0 2h1a5.006 5.006 0 0 0 5-5V2a2 2 0 0 0-2-2Z"/>
    </svg>
    <figcaption class="flex items-center justify-center mt-3 space-x-3 rtl:space-x-reverse">
        <img class="w-10 h-10 rounded-full" src="https://avatars.githubusercontent.com/u/2236138?s=200&v=4" alt="profile picture">
        <div class="flex items-center">
            <cite class="pl-0.5 font-medium text-gray-900">Joe Watkins</cite>
        </div>
    </figcaption>
</figure>

<blockquote>
  <p>When we established The PHP Foundation, we were focused on raising the bus factor of PHP.</p>
  
  <p>It's years later now, and the bus factor is no longer a major concern. The Foundation has contracted and trained very skilled developers, and the effort they have put in cannot be understated.<br />
  <br />
  Moreover, we have the means to train and pay new developers, should the ones we have now decide to pursue other professional opportunities.</p>
  
  <p>We also imagined that from The Foundation would emerge a vision for PHP, something loosely resembling a roadmap. This isn't because The Foundation wanted to take control of the direction of the project, but rather a more practical concern. Namely, it's difficult to get sponsorship for "maintenance and development". It's easier to convince businesses to sponsor our activities when we know our goals are aligned.</p>
  
  <p>No such road map has materialized; The Foundation has many generous businesses sponsoring the work that goes on, but the bi-directional communication between sponsors and developers is limited, and so alignment is not assured.</p>
  
  <p>I joined the foundation as a developer so that I can address this problem.</p>
  
  <p>My intention is to be the conduit between sponsors (the board members) and developers, to advocate for developers, and to communicate with them on behalf of the board.</p>
  
  <p>I will also, as a developer, be able to advance my own ideas for the future of PHP.</p>
  
  <p>PHP has been around for so long it feels like a part of the furniture of the web. It seems obvious that in ten years, PHP will still be relevant, as it was for the last ten and the ten years before that.</p>
  
  <p>This isn't really the case; PHP has thrived because the ecosystem of the web allowed it to. While internals is focused on the development of the language at a syntax and API level, there's limited discussion of PHP "the product". PHP is a product, and The Foundation has to function something like a business, although our profit is measured in progress rather than pennies. We need to ask questions about adoption rates and relevance in a changing digital landscape. We must be able to answer these questions.</p>
  
  <p>With an increase in bi-directional communication between board and developers, and the clarity this brings to our shared and declared goals, we can start to answer these questions.</p>
  
  <p>If I succeed in my goals, there will emerge a roadmap, a physical document you can link to. But perhaps more importantly, we will have the necessary processes and structure in place within The Foundation to develop and maintain that roadmap and required alignment so that our work continues to address the concerns of the businesses paying for it.</p>
</blockquote>

<p>Please join us in welcoming Joe back ‚Äî and if you haven‚Äôt yet, check out what he‚Äôs been working on: <a href="https://github.com/krakjoe">github.com/krakjoe</a>.</p>

<p>üíúüêò</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Announcing the Official PHP SDK for MCP]]></title>
            <link href="https://thephp.foundation/blog/2025/09/05/php-mcp-sdk/"/>
            <updated>2025-09-05T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/09/05/php-mcp-sdk/</id>
            <content type="html"><![CDATA[<p><strong>The PHP Foundation</strong>, <strong>Anthropic‚Äôs MCP team, and Symfony</strong> are collaborating on the <strong>official PHP SDK for the Model Context Protocol (MCP)</strong>. Our goal is a <strong>framework-agnostic, production-ready</strong> reference implementation the PHP ecosystem can rely on.</p>

<p>The Symfony team will lead maintenance, with contributions from the broader community, including <a href="https://github.com/CodeWithKyrian">Kyrian Obikwelu</a> (<a href="https://github.com/php-mcp">PHP-MCP</a>).</p>

<p>This initiative consolidates earlier work into a single, trusted implementation ‚Äì <a href="https://github.com/modelcontextprotocol/php-sdk"><strong>modelcontextprotocol/php-sdk</strong></a> ‚Äì starting with the server and expanding to client capabilities.</p>

<p>‚≠ê Star the repo, try it, open issues/PRs, and join discussions.</p>

<!--
- [Symfony announcement](https://symfony.com/blog/symfony-to-provide-the-official-mcp-sdk)  
- [MCP blog announcement]()
-->

<h2 id="%2A%2Awhat-is-mcp-and-why-is-it-important%2A%2A"><strong>What is MCP and why is it important</strong></h2>

<p>The <a href="https://modelcontextprotocol.io/">Model Context Protocol</a> (MCP) is an open protocol introduced by <a href="https://www.anthropic.com/">Anthropic</a> to enable AI applications to connect with and utilize external tools and data sources, akin to a standardized "USB-C port" for AI systems.</p>

<blockquote>
  <p>üí° Fun fact: MCP co-creator <a href="https://x.com/dsp_"><strong>David Soria Parra</strong></a> was release manager for <a href="https://wiki.php.net/todo/php54">PHP 5.4</a> and <a href="https://wiki.php.net/todo/php55">5.5</a>, and a long-time PHP core contributor. His PHP code still runs inside <a href="https://github.com/symfony/http-foundation/blob/6.1/IpUtils.php#L105">every Symfony and Laravel project</a> today. Cheers, David! üíú</p>
</blockquote>

<p>To make it easier to build MCP servers, the community provides SDKs ‚Äì lightweight frameworks that handle the protocol details so developers can focus on their applications.</p>

<p>There were several official SDKs for different programming languages. However, there was no official PHP SDK, even though a few community implementations existed.</p>

<p>That‚Äôs why <strong>the PHP Foundation stepped up to coordinate</strong> the development and maintenance of the official PHP SDK for MCP.</p>

<p>This brings two important benefits:</p>

<ul>
<li>A <strong>trusted reference implementation</strong> developers can rely on.</li>
<li>Visibility of <strong>PHP‚Äôs readiness for AI development</strong> outside its own ecosystem.</li>
</ul>

<h2 id="%2A%2Awhat%E2%80%99s-happening%2A%2A"><strong>What‚Äôs happening</strong></h2>

<p><strong>The PHP Foundation</strong> has partnered with the MCP team at <strong>Anthropic</strong> and the <strong>Symfony</strong> team to develop the <strong>official MCP SDK for PHP.</strong></p>

<p>The Symfony team will be lead maintainers of the SDK as they have a proven track record of building high-quality framework-agnostic components that much of the PHP ecosystem relies on.</p>

<p>Additionally, <a href="https://github.com/CodeWithKyrian">Kyrian Obikwelu</a> joined the maintainer team and brings his previous experience and work on MCP libraries. Other PHP MCP SDK authors are welcome to participate as well.</p>

<p><strong>Roadmap (high level):</strong></p>

<ol>
<li>Server-side building blocks (initial release)</li>
<li>Client capabilities and additional transports as the spec evolves</li>
<li>Docs, examples, and stability hardening driven by real-world use</li>
</ol>

<p>We‚Äôll keep this implementation framework-agnostic so it works well in any platform, legacy apps, and custom stacks. Community adapters and examples will live alongside the core packages.</p>

<h2 id="%2A%2Aget-involved%2A%2A"><strong>Get involved</strong></h2>

<p><strong>Try it:</strong> install the SDK, scaffold a small MCP server, and expose one or two safe tools.</p>

<p><strong>Contribute:</strong> issues, docs, and PRs are very welcome ‚Äì especially around testing, and real-world examples.</p>

<p><strong>Bring your framework:</strong> we‚Äôre keen on first‚Äëclass integrations for Laravel, WordPress, Drupal, Laminas, and more. We keep a list of integrations in the repo as well.</p>

<p><strong>Start here:</strong></p>

<ul>
<li>SDK repo: <a href="https://github.com/modelcontextprotocol/php-sdk"><strong>modelcontextprotocol/php-sdk</strong></a></li>
<li>Composer package: <a href="https://packagist.org/packages/mcp/sdk"><strong>https://packagist.org/packages/mcp/sdk</strong></a></li>
<li>MCP spec &amp; ecosystem: <a href="https://modelcontextprotocol.io/specification/2025-06-18"><strong>https://modelcontextprotocol.io/</strong></a></li>
</ul>

<blockquote>
  <p><a href="https://symfony.com/blog/let-s-build-the-symfony-ai-ecosystem-together"><strong>Join the Symfony AI Hackathon</strong></a><br />
  The in-person event will be <a href="https://maps.app.goo.gl/ML4e5SqtcwGRYJH8A">hosted at Quentic in Berlin</a>, and requires a <a href="https://www.eventbrite.com/e/symfony-ai-hackathon-tickets-1591414586869">free registration via Eventbrite</a> upfront. For online participation, please make sure to join our <a href="https://symfony.com/slack">Slack Workspace</a> and the &#35;ai channel to follow along and raise your topics or questions.</p>
</blockquote>

<p>This SDK helps ensure PHP is visible as a great language choice to a wider audience when working in the AI ecosystem.
Let‚Äôs build it together!<br />
üíúüêò</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Compile time generics: yay or nay?]]></title>
            <link href="https://thephp.foundation/blog/2025/08/05/compile-generics/"/>
            <updated>2025-08-05T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/08/05/compile-generics/</id>
            <content type="html"><![CDATA[<p>One of the most sought-after features for PHP is Generics: The ability to have a type that takes another type as a parameter.  It's a feature found in most compiled languages by now, but implementing generics in an interpreted language like PHP, where all the type checking would have to be done at runtime, has always proven Really Really Hard(tm), Really Really Slow(tm), or both.</p>

<p>But, experimentation by Gina from the PHP Foundation's dev team suggests we may be able to get 80% of the benefit for 20% of the work.  Is that enough?</p>

<h2 id="the-short%2C-short-version">The short, short version</h2>

<p>Gina and Larry believe it's possible to implement generics on only interfaces and abstract classes, which would offer a large chunk of the benefit of generics but avoid most of the pitfalls.</p>

<p>In particular, interfaces and abstract classes could declare that they need one or more types specified:</p>

<pre><code class="php">interface Exporter&lt;Thing&gt; { ... }
</code></pre>

<p>And then classes that implement/extend them would be required to fill in those types:</p>

<pre><code class="php">class WidgetExporter implements Exporter&lt;Widget&gt; { ... }
</code></pre>

<p>And then anywhere the type <code>Thing</code> appeared in <code>Exporter</code>, it would turn into <code>Widget</code> in <code>WidgetExporter</code>.</p>

<p>All of this is done at compile time, which makes it far easier and faster, and many/most errors would be caught at compile time.</p>

<p>Runtime generics, where you could say <code>$fooExporter = new Exporter&lt;Foo&gt;()</code>, would still not be possible, but they do not get any harder as a result of going just part way.</p>

<p><strong>Would you support (and vote in favor of) compile-time-only generics as described below?</strong></p>

<h2 id="prior-research">Prior research</h2>

<p>In 2023 and 2024, Arnaud Le Blanc from the Foundation team did <a href="https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections/">extensive experimentation</a> on generics, picking up on the previous work from Nikita Popov.  The full result of that experiment is available at that link, but in short, some parts of generics would be possible, even straightforward.  Where the edge cases run into problems, though, they are very big problems.</p>

<p>In particular:</p>

<ul>
<li>Union types and generics combine to produce massive performance penalties.</li>
<li>Many cases would result in a very cumbersome syntax unless we had really good type inference.</li>
<li>Really good type inference is hard and slow, especially in PHP.</li>
</ul>

<p>Meanwhile, making arrays generic, and therefore typed, had its own challenges, especially given that PHP variables are not typed.</p>

<p>Arnaud and Larry Garfield did further investigation afterward into introducing <a href="https://github.com/Crell/php-rfcs/blob/master/modules/spec-brainstorm.md">a "module" system</a> that would help PHP's compiler <a href="https://github.com/arnaud-lb/php-src/pull/10">see more code at once</a>, and thus be able to do type inference more readily, but sadly that also ran into many challenging edge cases.</p>

<h2 id="associated-types">Associated Types</h2>

<p>In mid-2025, the Foundation's Gina Banyard started working on "associated types," a generics-adjacent feature found in a few languages that happens entirely at compile time. It essentially allows a class or interface to specify that inheritors must specify a type to be used in certain situations.  Initially, it was intended as an alternative to the <a href="https://wiki.php.net/rfc/never-parameters-v2"><code>never</code> parameters</a> RFC, offering a better solution to the case of an interface that doesn't need to specify a particular type, but implementing classes do.</p>

<p>The initial plan looked something like this:</p>

<pre><code class="php">interface ImporterExporter
{
    type T;

    public function import(string $input): T;

    public function export(T $value): string;
}

class ThingImporter implements ImporterExporter
{
    public function import(string $input): Thing { ... }

    public function export(Thing $value): string { ... }
}
</code></pre>

<p>In which all references to <code>T</code> in the interface need to be replaced by the <em>same</em> type in the class; it can be any type, as long as it's the same in all cases.</p>

<p>After some discussion with the rest of the team, however, it became apparent that if we just changed the spelling and squinted, associated types look an awful lot like generics.  Or rather, part of generics, as full generics is a very involved bit of functionality with lots of different complimentary parts.</p>

<p>Which begged the question: Could we just do some of those parts, and get most of the benefit?  According to Gina's work, the answer is "Probably!"</p>

<h2 id="abstract-generics">Abstract Generics</h2>

<p>What Gina has implemented, though it still needs some polish and extension, is essentially "manually monomorphized generics," implemented at compile time.  "Monomorphization" is an approach to generics (there are others) where a type-specific version of a class is created "on the fly" by the compiler or engine when that type-specific version is used.  By "manual," we mean that it's up to the developer to do so in advance.</p>

<p>Let's see what that looks like in practice.</p>

<p>Consider our previous interface, but spelled this way instead:</p>

<pre><code class="php">interface ImporterExporter&lt;T&gt;
{
    public function import(string $input): T;

    public function export(T $value): string;
}
</code></pre>

<p>That interface requires that any class implementing it specify what type <code>T</code> should be; it can be any type, as long as it's the same type in both places.</p>

<pre><code class="php">class ThingExporter implements ImporterExporter&lt;Thing&gt;
{
    public function import(string $input): Thing { ... }

    public function export(Thing $value): string { ... }
}

class WidgetExporter implements ImporterExporter&lt;Widget&gt;
{
    public function import(string $input): Widget { ... }

    public function export(Widget $value): string { ... }
}
</code></pre>

<p>This can all be enforced at compile time, where it's much cheaper, and cached by the opcache.</p>

<p>This alone is not full generics capability, but it is in practice a good chunk of it.  It's also possible to specify that the generic type must conform to some other type, like another interface.  For instance:</p>

<pre><code class="php">interface Repository&lt;T: Entity&gt;
{
    public function save(T $entity): bool;

    public function load(int $id): T;
}

class BlogPostRepository implements Repository&lt;BlogPost&gt;
{
    // ...
}
</code></pre>

<p>This would work, but only if <code>BlogPost</code> implements the <code>Entity</code> interface.</p>

<h2 id="a-few-more-parts">A few more parts</h2>

<p>Although not yet implemented, Gina is confident that a few natural extensions are also possible and straightforward, if enough time is put into them.  They could probably be included in the initial RFC.</p>

<p>First, allowing abstract classes to be generic as well.  That would allow for:</p>

<pre><code class="php">abstract class BaseRepository&lt;T: Entity&gt;
{ 
    // ...
}

class BlogPostRepository extends BaseRepository&lt;BlogPost&gt; { ... }
</code></pre>

<p>Of particular note, the inheriting class wouldn't need to actually <em>do</em> anything beyond specifying the type.  That would be enough.  The net result is that we may see a proliferation of "empty extending classes" that just specify a type and have no body of their own, as a surrogate for what in other languages would be <code>$repo = new Repository&lt;BlogPost&gt;()</code>.  In PHP, that would instead be spelled:</p>

<pre><code class="php">class BlogPostRepository extends BaseRepository&lt;BlogPost&gt; { ... }
$repo = new BlogPostRepository();
</code></pre>

<p>(That's the "manual monomorphization" we talked about.)  Not ideal, but still much more powerful than the status quo as of PHP 8.4.</p>

<p>Second, type declarations.  It would already be possible to type against <code>BlogPostRepository</code>, as that's just a boring old class like we've always known.  What would be a straightforward extension is allowing this:</p>

<pre><code class="php">class DataProcessor
{
    public function __construct(private Repository&lt;UserEntity&gt; $repo) {}
}
</code></pre>

<p>That is, declare that <code>$repo</code> must implement <code>Repository</code> <em>and</em> specify a type that is itself a child of <code>UserEntity</code> (which could be a class or another interface).  In the initial version it may not support a generic as part of a compound type (such as <code>private Repository&lt;UserEntity&gt;|null $repo</code>), but that should be feasible to add later, probably.</p>

<h2 id="collections">Collections</h2>

<p>One of the most common uses of generics is for collections, be they typed arrays or objects.  The details vary by language, but a collection known to be of a certain type is very valuable.  The previous blog post (linked above) included a discussion of a collection design by Derick Rethans and Larry Garfield, which included a custom one-off syntax for... essentially the behavior described here.  Updating that design for this syntax would give us three interfaces, or probably base classes:</p>

<pre><code class="php">abstract class Sequence&lt;T&gt;
{
    private array $values = [];

    public function append(T $new): static
    {
        $this-&gt;values[] = $new;
        return $this;
    }

    public filter(callable $filter): static
    {
        // ...
    }
}

abstract class Set&lt;T&gt;
{
    // ...
}

abstract class Dict&lt;K, V&gt;
{
    // ...
}
</code></pre>

<p>And then they could be used like so:</p>

<pre><code class="php">class Articles extends Sequence&lt;Article&gt; {}

class Library extends Set&lt;Book&gt; {}

class YearBooks extends Dict&lt;int, Book&gt; {}
</code></pre>

<p>Those concrete classes could have additional methods in them if desired, but that's optional.  The above would be sufficient to have a collection that mapped integers to Book objects, and had syntax-level guarantees those types would hold.</p>

<p>The above design could be implemented either in core or user-space.  There's definite benefit to them being built-in, but the type-control portion at least would be available to user-space code, too.</p>

<h2 id="longer-term">Longer term</h2>

<p>There's a few more complex features that seem like they are doable, but require enough extra effort that they almost certainly wouldn't make sense in the initial RFC.  They could probably be in their own future RFCs, however, barring any surprises.</p>

<h3 id="variance">Variance</h3>

<p>In the initial version, generic types would be invariant.  <code>BlogPostRepository</code> is a child of <code>BaseRepository</code>, but just because <code>FeaturedBlogPost</code> is a child of <code>BlogPost</code> doesn't mean <code>BlogPostRepository</code> can accept <code>FeaturedBlogPost</code>.  The challenge is that the variance of parameter and return types are in opposite directions, and because a generic type may appear both as a parameter type (which can be seen as a write context) and a return type (which can be seen as a read context) it needs to be invariant, similar to how property types are invariant.  (This is a common challenge in languages with generics.)</p>

<p>However, Kotlin and C# have a feature that we should be able to borrow for PHP.  If a generic type is used exclusively in parameters it can be marked as an <code>in</code> type to indicate it is contravariant.  For example:</p>

<pre><code class="php">interface Saver&lt;in Type&gt;
{
    public function save(Type $object): bool;
}

class BlogPostSaver&lt;BlogPost&gt;
{
    public function save(BlogPost $object): bool { ... }
}

$bsaver = new BlogPostSaver();
$bsaver-&gt;save(new FeaturedBlogPost());
</code></pre>

<p>Similarly, if a generic type is used exclusively as a return type, it can be marked <code>out</code>:</p>

<pre><code class="php">interface Loader&lt;out Type&gt;
{
    public function load(int $id): Type;
}

class BlogPostLoader&lt;BlogPost&gt;
{
    public function load(int $id): BlogPost { ... }
}

$bloader = new BlogPostLoader();
$post = $bloader-&gt;load(5);
// $post could be a FeaturedBlogPost, potentially.
</code></pre>

<p>There are still a lot of bits to figure out here that may make it even more complex than anticipated.  That's why we're not looking into it in detail yet, and leaving it for future scope.</p>

<h3 id="traits">Traits</h3>

<p>PHP, of course, has another class-esque construct, Traits.  How generics would interact with Traits is still unclear.  It seems likely that something along the lines of the following could be made to work eventually:</p>

<pre><code class="php">trait Tools&lt;T&gt; 
{
    public function useful(T $param): int { ... }
}

class C
{
    use Tools&lt;Book&gt;;
}
</code></pre>

<p>However, there are some notable challenges here, largely around performance and avoiding code duplication.  They are likely solvable, but sufficiently complex that they won't be in an initial version.</p>

<h3 id="generic-functions">Generic functions</h3>

<p>So far we've only been talking about classes and class-likes.  What about functions?</p>

<p>At least in theory, something like the following should be viable:</p>

<pre><code class="php">function compareThings&lt;Thing&gt;(Thing $thingOne, Thing $thingTwo) { ... };

compareThing&lt;Widget&gt;(new Widget(1), new Widget(2));
</code></pre>

<p>It's a bit clunky to have to specify the type manually on each call, but making that auto-detectable falls under the category of "type inference," as described below.</p>

<p>There probably aren't a huge number of use cases for this pattern in practice; mainly ensuring that two parameters or a parameter and return have the same unspecified type, which is fairly niche.  It's also unclear what implications it would have for methods.  It seems possible, but maybe not practical.</p>

<h2 id="what-is-still-hard">What is still hard</h2>

<p>Notably absent from the above plan are, well, the Really Really Hard(tm) bits.  At this time, it's still not clear that they would be possible.</p>

<h3 id="%60new%60-generics"><code>new</code> generics</h3>

<p>In particular, a syntax like <code>$blogRepo = new Repository&lt;BlogPost&gt;()</code> is still not on the table.  The challenge is that the partial approach described here can put all the extra tracking data it needs on the <em>class</em>, and do the work at compile time.  Supporting on-the-fly declarations with <code>new</code> would require putting the extra tracking data on the <em>object</em>, and doing all the work at runtime.  That's an order of magnitude harder.</p>

<h3 id="generic-compound-types">Generic compound types</h3>

<p>Few if any languages support both generic types and union types.  PHP has had union and intersection types for some time, and made largely judicious use of them.  However, trying to make a class generic over a compound type makes the whole thing exponentially more complex.  This is one of the areas that Arnaud ran into in his earlier research.  Code like the following will likely never be possible, at least not if we care about performance at all:</p>

<pre><code class="php">class SimpleRepository implements Repository&lt;BlogPost|User|Event&gt;
{
    // ...
}

class DataProcessor
{
    public function __construct(private Repository&lt;UserEntity|BlogPost&gt; $repo) {}
}
</code></pre>

<p>In practice, that's probably fine.  The situations where that would even be useful are few and far between.</p>

<p>As noted above, though, typing against a generic that is part of a union, like <code>public function setRepository(Repository&lt;UserEntity&gt;|null $repo) {}</code>, is probably possible in a follow-up RFC.</p>

<h3 id="type-inference">Type inference</h3>

<p>Type inference is a feature of many heavily typed languages where the compiler or engine can "figure out" what the type of something is supposed to be based on context.  As a trivial example:</p>

<pre><code class="php">function concat(string $x, string $y)
{
    return $x . $y;
}
</code></pre>

<p>It's readily obvious that the return type of that function is <code>string</code>, so a type inference engine will fill that in for you automatically.</p>

<p>That would be very helpful for Generics, especially if runtime Generics ever became possible.</p>

<pre><code class="php">class Car&lt;Driver&gt; {
    public function __construct(private Driver $driver) {}
}

// This full version
new Car&lt;StudentDriver&gt;(new StudentDriver());

// Could be abbreviated to this, and the engine would figure out the rest.
new Car(new StudentDriver());
</code></pre>

<p>A lot of Arnaud's research last year was into the feasibility of type inference to make generic code easier to work with.  This unfortunately remains in the Really Really Hard(tm) realm.  On the flipside, it's also largely irrelevant until and unless runtime generics (like in <code>new</code>) become feasible, which are already Really Really Hard(tm).</p>

<p>All of the above remain challenges to a full PHP generics implementation.  Importantly, however, they are not made any harder by Gina's work into just the compile-time parts.  There's no guarantee that they will ever be possible, but they are not made any less possible by adopting the parts of generics we can do.</p>

<h2 id="so%2C-should-we%3F">So, should we?</h2>

<p>This work is still experimental.  As noted above, there's a few additional features still to add, and dozens of edge cases and crufty corners to sort out.  (What happens if you implement two generic interfaces?  Do anonymous classes make anything weirder?  Etc.)  There's much work ahead to bring compile-time generics to a votable state.</p>

<p>The Foundation, of course, wants to be respectful of the time of our development team, the time of the many RFC reviewers, and the pocketbooks of our generous sponsors.  Foundation staff have already sunk quite a bit of time into the question of generics.  Before we sink more time into it, we want to ask the community (and PHP Internals especially)... Is it worth it?</p>

<p>Would a partial-generics approach like that described here be acceptable?  Even if it may not be possible to go all the way to full generics, would "compile time-only generics" be a big enough win to justify spending more time on it?  Gina from The PHP Foundation team thinks it is, but PHP is larger than just our team, so we want to get feedback from the broader community.</p>

<p><strong>Would you support (and vote in favor of) compile-time-only generics as described here?</strong></p>

<p><div
    class="thread-container"
    data-reddit-thread="https://www.reddit.com/r/PHP/comments/1mhe7qf/compile_time_generics_yay_or_nay/"
    data-reddit-max-depth="10"
    data-reddit-show-content="false"
    data-reddit-show-controls="true"
></div>
<script src="//unpkg.com/redditify/dist/redditify.min.js"></script>
<link rel="stylesheet" href="//unpkg.com/redditify/dist/redditify.css">
</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHP 8.5 Adds Pipe Operator: What it means]]></title>
            <link href="https://thephp.foundation/blog/2025/07/11/php-85-adds-pipe-operator/"/>
            <updated>2025-07-11T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/07/11/php-85-adds-pipe-operator/</id>
            <content type="html"><![CDATA[<p>PHP 8.5, due out November of this year, will bring with it another long-sought-after feature: the <a href="https://wiki.php.net/rfc/pipe-operator-v3">pipe operator</a> (<code>|&gt;</code>).  It's a small feature with huge potential, yet it still took years to happen.</p>

<h2 id="what-is-a-pipe-operator%3F">What is a pipe operator?</h2>

<p>The pipe operator, spelled <code>|&gt;</code>, is deceptively simple.  It takes the value on its left side and passes it as the single argument to a function (or in PHP's case, <code>callable</code>) on its right side:</p>

<pre><code class="php">$result = "Hello World" |&gt; strlen(...)

// Is equivalent to
$result = strlen("Hello World");
</code></pre>

<p>On its own, that is not all that interesting.  Where it becomes interesting is when it is repeated, or chained, to form a "pipeline."  For example, here's real code from a real project I've worked on, recast to use pipes:</p>

<pre><code class="php">$arr = [
  new Widget(tags: ['a', 'b', 'c']),
  new Widget(tags: ['c', 'd', 'e']),
  new Widget(tags: ['x', 'y', 'a']),
];

$result = $arr
    |&gt; fn($x) =&gt; array_column($x, 'tags') // Gets an array of arrays
    |&gt; fn($x) =&gt; array_merge(...$x)       // Flatten into one big array
    |&gt; array_unique(...)                  // Remove duplicates
    |&gt; array_values(...)                  // Reindex the array.
;

// $result is ['a', 'b', 'c', 'd', 'e', 'x', 'y']
</code></pre>

<p>The same code without pipes would require either this horribly ugly nest of evil:</p>

<pre><code class="php">array_values(array_unique(array_merge(...array_column($arr, 'tags'))));
</code></pre>

<p>Or manually creating a temporary variable for each step.  While temp variables are not the worst thing in the world, they are extra mental overhead, and mean that a chain like that cannot be used in a single-expression context, like a <code>match()</code> block.  A pipe chain can.</p>

<p>Anyone who has worked on the Unix/Linux command line will likely recognize the similarity to the shell pipe, <code>|</code>.  That's very deliberate, as it is effectively the same thing: Use the output from the left side as the input on the right side.</p>

<h2 id="where-did-it-come-from%3F">Where did it come from?</h2>

<p>The <code>|&gt;</code> operator appears in many languages, mostly in the functional world.  F# has essentially the exact same operator, as does OCaml.  Elixir has a slightly fancier version (which we considered but ultimately decided against for now).  Numerous PHP libraries exist in the wild that offer similar capability with many extra expensive steps, including my own <a href="https://github.com/Crell/fp/">Crell/fp</a>.</p>

<p>The story for PHP pipes, though, begins with Hack/HHVM, Facebook's PHP fork n√©e competitive implementation.  Hack included many features beyond what PHP 5 of the day offered; many of them eventually ended up in later PHP versions.  One of its features was a unique spin on a pipe operator.</p>

<p>In 2016, Sara Golemon, long-time PHP contributor and former Open Source lead on the HHVM project, proposed porting <a href="https://wiki.php.net/rfc/pipe-operator">Hack's pipes</a> to PHP directly.  In that RFC, the right side of a pipe wasn't a <code>callable</code> but an expression, and used a magic <code>$$</code> token (lovingly called <code>T_BLING</code>, at least according to yours truly) to inject the left-side result into it.  In that case, the example above would look like this:</p>

<pre><code class="php">$result = $arr
    |&gt; array_column($$, 'tags')
    |&gt; array_merge(...$$)
    |&gt; array_unique($$)
    |&gt; array_values($$)
;
</code></pre>

<p>While powerful, it was also somewhat limiting.  It was very non-standard, unlike any other language.  It also meant a weird, one-off syntax for partially-calling functions that worked only when paired with pipes.</p>

<p>That RFC didn't go as far as a vote.  Nothing much happened for several years, until 2020/2021.  That's when I, fresh off of writing a book on functional programming in PHP that talked about function composition, decided to take a swing at it.  In particular, I partnered with a team to work on <a href="https://wiki.php.net/rfc/partial_function_application">Partial Function Application</a> (PFA) as a separate RFC from a more <a href="https://wiki.php.net/rfc/pipe-operator-v2">traditional pipe</a>.  The idea was that turning a multi-parameter function (like <code>array_column()</code> above) into the single-parameter function that <code>|&gt;</code> needed was a useful feature on its own, and should be usable elsewhere.  The syntax was a bit different than the Hack version, in order to make it more flexible: <code>some_function(?, 5, ?, 3, ...)</code>, which would take a 5-or-more parameter function and turn it into a 3 parameter function.</p>

<p>Sadly, PFA didn't pass due to some engine complexity issues, and that largely undermined the v2 Pipe RFC, too.  However, we did get a consolation prize out of it: <a href="https://wiki.php.net/rfc/first_class_callable_syntax">First Class Callables</a> (the <code>array_values(...)</code> syntax), courtesy Nikita Popov, were by design a "junior", degenerate version of partial function application.</p>

<p>Fast-forward to 2025, and I was sufficiently bored to take another swing at pipes.  This time with a better implementation with lots of hand-holding from Ilija Tovilo and Arnaud Le Blanc, both part of the PHP Foundation dev team, I was able to get it through.</p>

<p>Third time's the charm.</p>

<h2 id="more-than-the-sum-of-its-parts">More than the sum of its parts</h2>

<p>Above, we described pipes as "deceptively simple."  The implementation itself is almost trivial; it's just syntax sugar for the temp variable version, effectively.  However, the best features are the ones that can combine with others or be used in novel ways to punch above their weight.</p>

<p>We saw above how a long array manipulation process could now be condensed into a single chained expression.  Now imagine using that in places where only a single expression is allowed, such as a <code>match()</code>:</p>

<pre><code class="php">$string = 'something GoesHERE';

$newString = match ($format) {
    'snake_case' =&gt; $string
        |&gt; splitString(...)
        |&gt; fn($x) =&gt; implode('_', $x)
        |&gt; strtolower(...),
    'lowerCamel' =&gt; $string
        |&gt; splitString(...),
        |&gt; fn($x) =&gt; array_map(ucfirst(...), $x)
        |&gt; fn($x) =&gt; implode('', $x)
        |&gt; lcfirst(...),
    // Other case options here.
};
</code></pre>

<p>Or, consider that the right-side can also be a function call that returns a <code>Closure</code>.  That means with a few functions that return functions:</p>

<pre><code class="php">$profit = [1, 4, 5] 
    |&gt; loadSeveral(...)
    |&gt; filter(isOnSale(...))
    |&gt; map(sellWidget(...))
    |&gt; array_sum(...);
</code></pre>

<p>Which... gives us mostly the same thing as the long-discussed scalar methods!  Only pipes are more flexible as you can use any function on the right-side, not just those that have been blessed by the language designers as methods.</p>

<p>At this point, pipe comes very close to being "extension functions", a feature of Kotlin and C# that allows writing functions that look like methods on an object, but are actually just stand-alone functions.  It's spelled a bit differently (<code>|</code> instead of <code>-</code>), but it's 75% of the way there, for free.</p>

<p>Or take it a step further.  What if some steps in the pipe may return <code>null</code>?  We can, with a single function, "lift" the elements of our chain to handle <code>null</code> values in the same fashion as null-safe methods.</p>

<pre><code class="php">function maybe(\Closure $c): \Closure
{
    return fn(mixed $arg) =&gt; $arg === null ? null : $c($arg);
}

$profit = [1, 4, 5] 
    |&gt; maybe(loadSeveral(...))
    |&gt; maybe(filter(isOnSale(...)))
    |&gt; maybe(map(sellWidget(...)))
    |&gt; maybe(array_sum(...));
</code></pre>

<p>That's right, we just implemented a Maybe Monad with a pipe and a single-line function.</p>

<p>Now, think about that for streams...</p>

<pre><code class="php">fopen('pipes.md', 'rb') // No variable, so it will close automatically when GCed.
    |&gt; decode_rot13(...)
    |&gt; lines_from_charstream(...)
    |&gt; map(str_getcsv(...))
    |&gt; map(Product::create(...))
    |&gt; map($repo-&gt;save(...))
;
</code></pre>

<p>The potential is absolutely huge.  I don't think it's immodest to say that the pipe operator has one of the highest "bangs for the buck" of any feature in recent memory, alongside such niceties as constructor property promotion.  And all thanks to a little syntax sugar.</p>

<h2 id="what-comes-next%3F">What comes next?</h2>

<p>Although pipes are a major milestone, we're not done.  There is active work on not one but two follow-up RFCs.</p>

<p>The first is a second attempt at <a href="https://wiki.php.net/rfc/partial_function_application_v2">Partial Function Application</a>.  This is a larger feature, but with first-class callables already bringing in much of the necessary plumbing, which simplifies the implementation.  With pipes now providing a natural use case, as well as easy optimization points, it's worth a second attempt.  Whether it makes it into PHP 8.5, is delayed to 8.6, or is again rejected is still an open question as of this writing, though I am hopeful.  Major thanks to Arnaud Le Blanc from the PHP Foundation team for picking it up to update the implementation.</p>

<p>The second is a <a href="https://wiki.php.net/rfc/function-composition">function composition operator</a>.  Where pipe executes immediately, function composition creates a new function by sticking two functions end-to-end.  That would mean the streams example above could be further optimized by combining the <code>map()</code> calls:</p>

<pre><code class="php">fopen('pipes.md', 'rb')
    |&gt; decode_rot13(...)
    |&gt; lines_from_charstream(...)
    |&gt; map(str_getcsv(...) + Product::create(...) + $repo-&gt;save(...))
;
</code></pre>

<p>This one is definitely not going to make it into PHP 8.5, but I am hopeful that we'll be able to get it into 8.6.  Stay tuned.</p>

<blockquote>
  <p>Special thanks to Ilija Tovilo and Arnaud Le Blanc from the PHP Foundation team for their assistance with the pipe implementation.  If you‚Äôd like to help push PHP forward, consider <a href="https://thephp.foundation/sponsor/">becoming a sponsor</a>.</p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[30 years of PHP: FrankenPHP is now part of the PHP organisation]]></title>
            <link href="https://thephp.foundation/blog/2025/06/08/php-30/"/>
            <updated>2025-06-08T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/06/08/php-30/</id>
            <content type="html"><![CDATA[<p>On June 8, 1995, Rasmus Lerdorf released the first version of the PHP language. Over time, PHP has become the most popular server-side programming language, now powering over 70% of websites!</p>

<p>Exactly 30 years after the first release of PHP, we are proud to announce that <a href="https://frankenphp.dev">FrankenPHP</a>, a modern and high-performance application server based on Caddy, is now part of <a href="https://github.com/php/frankenphp">the PHP organisation on GitHub</a>.</p>

<p>As a reminder, FrankenPHP offers features that are unique in the PHP ecosystem:</p>

<ul>
<li>simplify the development of applications written in PHP;</li>
<li>drastically improve performance, while considerably reducing hosting costs (FinOps) and energy consumption (GreenOps);</li>
<li>facilitate deployment in production, whether on bare-metal servers, or in cloud-native environments;</li>
<li>easily develop real-time features thanks to native <a href="https://mercure.rocks">Mercure</a> protocol support;</li>
<li>extend PHP apps with Go, C, and C++ programming languages;</li>
<li>support the PHP programming language in any application written in Go (server, proxy, in-house development‚Ä¶).</li>
</ul>

<p>The move of FrankenPHP into the PHP organisation follows the announcement of FrankenPHP support by the PHP Foundation, in collaboration with <a href="https://les-tilleuls.coop">Les-Tilleuls.coop</a> (the creator of FrankenPHP) and the team maintaining <a href="https://caddyserver.com">the Caddy web server</a>.</p>

<p>This is the first step towards greater integration of the tool into the language ecosystem.</p>

<p>The roadmap and new features that are likely to change the way PHP applications are developed will be announced at the <strong><a href="https://jb.gg/phpverse-phpf">JetBrains PHPverse 2025</a></strong> online conference on <strong>June 17</strong>, to celebrate PHP's 30th birthday. There is still time to register, and it's free!</p>

<p><a href="https://jb.gg/phpverse-phpf"><img src="/assets/post-images/2025/phpverse_2025.gif" alt="" /></a></p>

<p>Happy 30th birthday, PHP! üéâ</p>

<p>üêòüíú</p>

<p><div
    class="thread-container"
    data-reddit-thread="https://www.reddit.com/r/PHP/comments/1l7v0df/30_years_of_php_frankenphp_is_now_part_of_the_php/"
    data-reddit-max-depth="10"
    data-reddit-show-content="false"
    data-reddit-show-controls="true"
></div>
<script src="//unpkg.com/redditify/dist/redditify.min.js"></script>
<link rel="stylesheet" href="//unpkg.com/redditify/dist/redditify.css">
</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[FrankenPHP Is Now Officially Supported by&nbsp;The&nbsp;PHP&nbsp;Foundation]]></title>
            <link href="https://thephp.foundation/blog/2025/05/15/frankenphp/"/>
            <updated>2025-05-15T00:00:00+00:00</updated>
            <id>https://thephp.foundation/blog/2025/05/15/frankenphp/</id>
            <content type="html"><![CDATA[<p><a href="https://frankenphp.dev">FrankenPHP</a>, a modern high-performance PHP application server created by <a href="https://dunglas.dev">K√©vin Dunglas</a> and sponsored by <a href="http://Les-Tilleuls.coop">Les-Tilleuls.coop</a>, is now officially supported by the PHP Foundation. FrankenPHP integrates PHP directly into Go and Caddy, simplifying deployment, improving performance, and reducing costs. It powers real-time features, supports advanced hosting scenarios, and offers a performance-boosting ‚Äúworker mode‚Äù already integrated by Laravel, Symfony, and Yii. The PHP Foundation will actively contribute to FrankenPHP‚Äôs development and host its code on the official PHP GitHub, marking a major step toward modernizing the PHP ecosystem while keeping governance with the original maintainers.</p>

<p><img src="/assets/post-images/2025/2025-05-15-frankenphp.png" alt="FrankenPHP-PHP-Foundation" /></p>

<p>PHP is a programming language used by around 70% of websites and applications, and by key software and frameworks such as <a href="https://wordpress.org">WordPress</a>, <a href="https://laravel.com">Laravel</a>, and <a href="https://symfony.com">Symfony</a>.</p>

<p>FrankenPHP offers a host of new features that allow to:</p>

<ul>
<li>simplify the development of applications written in PHP;</li>
<li>drastically improve performance, while considerably reducing hosting costs (FinOps) and energy consumption (GreenOps);</li>
<li>facilitate deployment in production, whether on bare-metal servers or in cloud-native environments;</li>
<li>easily develop real-time features thanks to native <a href="https://mercure.rocks">Mercure</a> protocol support;</li>
<li>extend PHP apps with Go, C, and C++ programming languages;</li>
<li>support the PHP programming language in any application written in Go (server, proxy, in-house development...).</li>
</ul>

<p>Specifically, FrankenPHP integrates the official PHP interpreter as a module for Go and <a href="https://caddyserver.com">Caddy</a>, the popular next-generation web server that supports the latest web platform innovations in terms of performance, security, and DevOps: HTTP/3, compression with Zstandard, 103 Early Hints, automatic generation and renewal of HTTPS certificates, Encrypted Client Hello, structured logs, OpenMetrics/Prometheus metrics‚Ä¶ Caddy is also co-maintained by K√©vin and sponsored by Les-Tilleuls.coop.</p>

<p>Thanks to its innovative architecture, FrankenPHP lets you install a complete PHP environment (interpreter, web server, extensions, etc.) optimized for performance and security, by downloading a standalone statically compiled executable or a Docker image.</p>

<p>FrankenPHP also offers a performance-optimized mode called ‚Äúworker mode‚Äù, which takes advantage of the capabilities of the Go programming language. When this optional mode is used, the PHP application will be able to retain in memory those elements that can be reused to process other HTTP requests instead of being completely reset to process each incoming HTTP request (‚Äúshare nothing‚Äù model). Worker mode is especially useful for frameworks such as Symfony and Laravel that can prevent rebuilding their kernels and services again and again for nothing.</p>

<p>Using this mode requires minimal adaptations to the code of modern PHP applications in line with good programming practice. The Laravel, Symfony and Yii frameworks already offer official integrations of FrankenPHP's worker mode, enabling worker mode to be activated without modifying the application code.</p>

<p>According to <a href="https://sylius.com/blog/ecosystem/month-of-sylius-august-2024/#frankenphp">an analysis carried out this summer by Sylius</a>, the publisher of the eponymous e-commerce platform, the use of FrankenPHP's worker mode reduces the software's response times by 80%, while reducing by more than 6 the number of machines required to serve the same number of users.</p>

<p>FrankenPHP is now a reliable, mature solution used in production for an ever-increasing number of projects. The project now has <a href="https://github.com/dunglas/frankenphp">almost 8,000 stars on GitHub</a>, has passed the symbolic 100-contributor mark, and is officially supported by numerous hosting providers, including Upsun, Laravel Cloud, and Clever Cloud.</p>

<p>To get to this point, it was necessary to initiate close collaboration between the development teams of FrankenPHP, the PHP interpreter itself, the Caddy web server, and even the Go programming language.</p>

<p>Today, we're proud to announce that, with the aim of intensifying this collaboration, enabling the project to gain momentum, and modernizing the entire PHP ecosystem, <strong>the FrankenPHP project is now officially supported by the PHP Foundation</strong>.</p>

<p>In concrete terms, FrankenPHP's source code will be transferred to the PHP project's GitHub organization, and the PHP Foundation team will contribute to the maintenance and development of FrankenPHP to ensure its reliability, durability, and compatibility with the latest language innovations.</p>

<p>Part of the FrankenPHP documentation will also be transferred to the PHP website.</p>

<p>The governance of the project remains unchanged, and the current team of maintainers (K√©vin Dunglas, Robert Landers, Alexander Stecher) will continue to be in charge of releases, as well as code reviews. They will be actively collaborating with the PHP Foundation team in charge of the language development.</p>

<p>In addition to the support provided by the foundation, Les-Tilleuls.coop will continue to sponsor FrankenPHP (as well as PHP and Caddy) by providing developers and contributing financially.</p>

<p>FrankenPHP is already <a href="https://caddyserver.com/#:~:text=4x%20faster%20PHP%20apps">promoted by Caddy</a> as the official, modern solution for using PHP with this server.<br />
In the future, to simplify the PHP development experience (one-line installation of a complete development environment) and to promote a solution that, for projects requiring it, considerably improves the performance and efficiency of PHP applications, FrankenPHP may be highlighted on the PHP website as one of the ways to use the language (other SAPIs such as PHP-FPM will continue to be fully supported solutions).</p>

<p>To find out more about FrankenPHP and the many new possibilities it offers, take a look at <a href="https://frankenphp.dev">its documentation</a>. To meet the software's authors and find out how it is used in production, don't miss <a href="https://api-platform.com/con/">the API Platform conference</a> (by the same authors as FrankenPHP) taking place on September 18 and 19 in France (Lille).</p>

<p>Also, join us online for <a href="https://lp.jetbrains.com/phpverse-2025/"><strong>PHPverse on June 17</strong></a> ‚Äî a special event celebrating PHP‚Äôs 30th anniversary.</p>

<p>Finally, to help keep the PHP ecosystem innovating, <a href="https://thephp.foundation/sponsor/">support the foundation</a>!</p>

<p><a href="https://thephp.foundation/">The PHP Foundation</a><br />
<a href="http://Les-Tilleuls.coop">Les-Tilleuls.coop</a><br />
<a href="https://caddyserver.com">The Caddy team</a></p>
]]></content>
        </entry>
    </feed>